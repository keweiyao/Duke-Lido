<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="hcubature_8cpp" kind="file" language="C++">
    <compoundname>hcubature.cpp</compoundname>
    <includes local="no">stdio.h</includes>
    <includes local="no">stdlib.h</includes>
    <includes local="no">string.h</includes>
    <includes local="no">math.h</includes>
    <includes local="no">limits.h</includes>
    <includes local="no">float.h</includes>
    <includes refid="cubature_8h" local="yes">cubature.h</includes>
    <includes refid="converged_8h" local="yes">converged.h</includes>
    <includes refid="vwrapper_8h" local="yes">vwrapper.h</includes>
    <incdepgraph>
      <node id="1">
        <label>src/hcubature.cpp</label>
        <link refid="hcubature_8cpp"/>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="5" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
      </node>
      <node id="7">
        <label>float.h</label>
      </node>
      <node id="3">
        <label>stdlib.h</label>
      </node>
      <node id="9">
        <label>converged.h</label>
        <link refid="converged_8h_source"/>
      </node>
      <node id="6">
        <label>limits.h</label>
      </node>
      <node id="10">
        <label>vwrapper.h</label>
        <link refid="vwrapper_8h_source"/>
      </node>
      <node id="4">
        <label>string.h</label>
      </node>
      <node id="5">
        <label>math.h</label>
      </node>
      <node id="8">
        <label>cubature.h</label>
        <link refid="cubature_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
      </node>
      <node id="2">
        <label>stdio.h</label>
      </node>
    </incdepgraph>
    <innerclass refid="structesterr" prot="public">esterr</innerclass>
    <innerclass refid="structhypercube" prot="public">hypercube</innerclass>
    <innerclass refid="structregion" prot="public">region</innerclass>
    <innerclass refid="structrule__s" prot="public">rule_s</innerclass>
    <innerclass refid="structrule75genzmalik" prot="public">rule75genzmalik</innerclass>
    <innerclass refid="structheap" prot="public">heap</innerclass>
      <sectiondef kind="define">
      <memberdef kind="define" id="hcubature_8cpp_1aa90cac659d18e8ef6294c7ae337f6b58" prot="public" static="no">
        <name>SUCCESS</name>
        <initializer>0</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="109" column="9" bodyfile="src/hcubature.cpp" bodystart="109" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="hcubature_8cpp_1a6d58f9ac447476b4e084d7ca383f5183" prot="public" static="no">
        <name>FAILURE</name>
        <initializer>1</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="110" column="9" bodyfile="src/hcubature.cpp" bodystart="110" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="hcubature_8cpp_1a46a93ad5a840e2ebf85371ee68dfdd30" prot="public" static="no">
        <name>num0_0</name>
        <param><defname>dim</defname></param>
        <initializer>(1U)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="416" column="9" bodyfile="src/hcubature.cpp" bodystart="416" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="hcubature_8cpp_1a93d2daad3a6a67b35535f685ccb47e05" prot="public" static="no">
        <name>numR0_0fs</name>
        <param><defname>dim</defname></param>
        <initializer>(2 * (dim))</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="417" column="9" bodyfile="src/hcubature.cpp" bodystart="417" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="hcubature_8cpp_1aaf38ff3648534ca2a5d4158cfaeef4cc" prot="public" static="no">
        <name>numRR0_0fs</name>
        <param><defname>dim</defname></param>
        <initializer>(2 * (dim) * (dim-1))</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="418" column="9" bodyfile="src/hcubature.cpp" bodystart="418" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="hcubature_8cpp_1ab40d68352eadf82cdb3cb986a028be13" prot="public" static="no">
        <name>numR_Rfs</name>
        <param><defname>dim</defname></param>
        <initializer>(1U &lt;&lt; (dim))</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="419" column="9" bodyfile="src/hcubature.cpp" bodystart="419" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="hcubature_8cpp_1ab4cafb1ab351d520eb09a05ebd0a1e13" prot="public" static="no">
        <name>real</name>
        <param><defname>x</defname></param>
        <initializer>((double)(x))</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="442" column="9" bodyfile="src/hcubature.cpp" bodystart="442" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="hcubature_8cpp_1ab8dd298f9033091ef1d92dde601e2c76" prot="public" static="no">
        <name>to_int</name>
        <param><defname>n</defname></param>
        <initializer>((int)(n))</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="443" column="9" bodyfile="src/hcubature.cpp" bodystart="443" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="hcubature_8cpp_1af5b6c9023110ec7196962284ee14a8b3" prot="public" static="no">
        <name>VALS</name>
        <param><defname>i</defname></param>
        <initializer>v[fdim*(i)]</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="517" column="18"/>
      </memberdef>
      <memberdef kind="define" id="hcubature_8cpp_1adcaf3cd6c918fe13873c1a7585ff3054" prot="public" static="no">
        <name>KEY</name>
        <param><defname>hi</defname></param>
        <initializer>((hi).errmax)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="773" column="9" bodyfile="src/hcubature.cpp" bodystart="773" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="hcubature_8cpp_1aeeab8fbd26c52f7582ceac56f8c53076" prot="public" static="no">
        <name>ERR</name>
        <param><defname>j</defname></param>
        <initializer>ee[j].err</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="896" column="9"/>
      </memberdef>
      <memberdef kind="define" id="hcubature_8cpp_1a53800dab89b6b085340813d59c796bfa" prot="public" static="no">
        <name>VAL</name>
        <param><defname>j</defname></param>
        <initializer>ee[j].val</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="897" column="9"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="hcubature_8cpp_1a842ca4c35f50ce74052565579ad3a2a9" prot="public" static="no">
        <type>int(*</type>
        <definition>typedef int(* evalError_func) (struct rule_s *r, unsigned fdim, integrand_v f, void *fdata, unsigned nR, region *R)</definition>
        <argsstring>)(struct rule_s *r, unsigned fdim, integrand_v f, void *fdata, unsigned nR, region *R)</argsstring>
        <name>evalError_func</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="222" column="9" bodyfile="src/hcubature.cpp" bodystart="222" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="hcubature_8cpp_1aba4657cb4d54c6538e3c2561f2fd7aae" prot="public" static="no">
        <type>void(*</type>
        <definition>typedef void(* destroy_func) (struct rule_s *r)</definition>
        <argsstring>)(struct rule_s *r)</argsstring>
        <name>destroy_func</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="225" column="9" bodyfile="src/hcubature.cpp" bodystart="225" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="hcubature_8cpp_1ae648232412b13de3ed777a59b4d80128" prot="public" static="no">
        <type>struct <ref refid="structrule__s" kindref="compound">rule_s</ref></type>
        <definition>typedef struct rule_s rule</definition>
        <argsstring></argsstring>
        <name>rule</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="236" column="6"/>
      </memberdef>
      <memberdef kind="typedef" id="hcubature_8cpp_1a53548373573084fcad054978605c2277" prot="public" static="no">
        <type><ref refid="structregion" kindref="compound">region</ref></type>
        <definition>typedef region heap_item</definition>
        <argsstring></argsstring>
        <name>heap_item</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="772" column="16" bodyfile="src/hcubature.cpp" bodystart="772" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="var">
      <memberdef kind="variable" id="hcubature_8cpp_1afa4a7fee02568f49ae64ee71e2011144" prot="public" static="no" mutable="no">
        <type>int unsigned</type>
        <definition>int unsigned fdim</definition>
        <argsstring></argsstring>
        <name>fdim</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="904" column="14" bodyfile="src/hcubature.cpp" bodystart="904" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="hcubature_8cpp_1ac48d1042c1e921157302b1311139a4fc" prot="public" static="no" mutable="no">
        <type>int unsigned integrand_v</type>
        <definition>int unsigned integrand_v f</definition>
        <argsstring></argsstring>
        <name>f</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="905" column="13" bodyfile="src/hcubature.cpp" bodystart="905" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="hcubature_8cpp_1af9c4cd57d41446133be84239ba6fcb35" prot="public" static="no" mutable="no">
        <type>int unsigned integrand_v void *</type>
        <definition>int unsigned integrand_v void* fdata</definition>
        <argsstring></argsstring>
        <name>fdata</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="905" column="20" bodyfile="src/hcubature.cpp" bodystart="905" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="hcubature_8cpp_1a6f757c6ac1179b9cac478b18da8f48ff" prot="public" static="no" mutable="no">
        <type>int unsigned integrand_v void const <ref refid="structhypercube" kindref="compound">hypercube</ref> *</type>
        <definition>int unsigned integrand_v void const hypercube* h</definition>
        <argsstring></argsstring>
        <name>h</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="906" column="17" bodyfile="src/hcubature.cpp" bodystart="906" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="hcubature_8cpp_1a80c2052155894f3bb6ec690b40cf4138" prot="public" static="no" mutable="no">
        <type>int unsigned integrand_v void const <ref refid="structhypercube" kindref="compound">hypercube</ref> size_t</type>
        <definition>int unsigned integrand_v void const hypercube size_t maxEval</definition>
        <argsstring></argsstring>
        <name>maxEval</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="907" column="8" bodyfile="src/hcubature.cpp" bodystart="907" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="hcubature_8cpp_1a913428b94f48098066a986506c0de65c" prot="public" static="no" mutable="no">
        <type>int unsigned integrand_v void const <ref refid="structhypercube" kindref="compound">hypercube</ref> size_t double</type>
        <definition>int unsigned integrand_v void const hypercube size_t double reqAbsError</definition>
        <argsstring></argsstring>
        <name>reqAbsError</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="908" column="8" bodyfile="src/hcubature.cpp" bodystart="908" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="hcubature_8cpp_1aa5d70d093dbdb1854485dd9f464d7a37" prot="public" static="no" mutable="no">
        <type>int unsigned integrand_v void const <ref refid="structhypercube" kindref="compound">hypercube</ref> size_t double double</type>
        <definition>int unsigned integrand_v void const hypercube size_t double double reqRelError</definition>
        <argsstring></argsstring>
        <name>reqRelError</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="908" column="27" bodyfile="src/hcubature.cpp" bodystart="908" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="hcubature_8cpp_1a83a5030c0d61d8c57b35b08bea178e4f" prot="public" static="no" mutable="no">
        <type>int unsigned integrand_v void const <ref refid="structhypercube" kindref="compound">hypercube</ref> size_t double double error_norm</type>
        <definition>int unsigned integrand_v void const hypercube size_t double double error_norm norm</definition>
        <argsstring></argsstring>
        <name>norm</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="909" column="12" bodyfile="src/hcubature.cpp" bodystart="909" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="hcubature_8cpp_1ada65af0916682d0dd357df9da3af27b0" prot="public" static="no" mutable="no">
        <type>int unsigned integrand_v void const <ref refid="structhypercube" kindref="compound">hypercube</ref> size_t double double error_norm double *</type>
        <definition>int unsigned integrand_v void const hypercube size_t double double error_norm double* val</definition>
        <argsstring></argsstring>
        <name>val</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="910" column="8" bodyfile="src/hcubature.cpp" bodystart="910" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="hcubature_8cpp_1af208ea0774962f86bc560d4f949fba76" prot="public" static="no" mutable="no">
        <type>int unsigned integrand_v void const <ref refid="structhypercube" kindref="compound">hypercube</ref> size_t double double error_norm double double *</type>
        <definition>int unsigned integrand_v void const hypercube size_t double double error_norm double double* err</definition>
        <argsstring></argsstring>
        <name>err</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="910" column="19" bodyfile="src/hcubature.cpp" bodystart="910" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="hcubature_8cpp_1aabe36ff13d6e9f6e53663cb20d139340" prot="public" static="no" mutable="no">
        <type>int unsigned integrand_v void const <ref refid="structhypercube" kindref="compound">hypercube</ref> size_t double double error_norm double double int</type>
        <definition>int unsigned integrand_v void const hypercube size_t double double error_norm double double int parallel</definition>
        <argsstring></argsstring>
        <name>parallel</name>
        <initializer>{
     size_t numEval = 0</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="910" column="27" bodyfile="src/hcubature.cpp" bodystart="911" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="hcubature_8cpp_1a9d211cb4044c5e843759496cb408e0e2" prot="public" static="no" mutable="no">
        <type><ref refid="structheap" kindref="compound">heap</ref></type>
        <definition>heap_free &amp; regions</definition>
        <argsstring></argsstring>
        <name>regions</name>
        <initializer>= heap_alloc(1, fdim)</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="913" column="11" bodyfile="src/hcubature.cpp" bodystart="913" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="hcubature_8cpp_1ac23062089f3a5a2693cbb4ce7a75f1e5" prot="public" static="no" mutable="no">
        <type>unsigned</type>
        <definition>unsigned i</definition>
        <argsstring></argsstring>
        <name>i</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="914" column="15" bodyfile="src/hcubature.cpp" bodystart="914" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="hcubature_8cpp_1ab4f6b3aed51d8a9b2ada1ad5390fb569" prot="public" static="no" mutable="no">
        <type>unsigned</type>
        <definition>unsigned j</definition>
        <argsstring></argsstring>
        <name>j</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="914" column="17" bodyfile="src/hcubature.cpp" bodystart="914" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="hcubature_8cpp_1a09bc594fe13bba38c1fb83020dbafcc9" prot="public" static="no" mutable="no">
        <type><ref refid="structregion" kindref="compound">region</ref> *</type>
        <definition>R[0]</definition>
        <argsstring></argsstring>
        <name>R</name>
        <initializer>= NULL</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="915" column="13" bodyfile="src/hcubature.cpp" bodystart="915" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="hcubature_8cpp_1af3e9be5f99c9f3bb1de1b64f0d91aa99" prot="public" static="no" mutable="no">
        <type>size_t</type>
        <definition>nR_alloc</definition>
        <argsstring></argsstring>
        <name>nR_alloc</name>
        <initializer>= 0</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="916" column="13" bodyfile="src/hcubature.cpp" bodystart="916" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="hcubature_8cpp_1a670da91be64127c92faac35c8300e814" prot="public" static="no" mutable="no">
        <type><ref refid="structesterr" kindref="compound">esterr</ref> *</type>
        <definition>ee</definition>
        <argsstring></argsstring>
        <name>ee</name>
        <initializer>= NULL</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="917" column="13" bodyfile="src/hcubature.cpp" bodystart="917" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="hcubature_8cpp_1a40f6b3a2061883919852d0311c370324" prot="public" static="no" mutable="no">
        <type></type>
        <definition>numEval</definition>
        <argsstring></argsstring>
        <name>numEval</name>
        <initializer>= r-&gt;num_points</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="936" column="6" bodyfile="src/hcubature.cpp" bodystart="936" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="hcubature_8cpp_1a48b99cf368a45012ab09b826df3b90a4" prot="public" static="no" mutable="no">
        <type>return</type>
        <definition>return SUCCESS</definition>
        <argsstring></argsstring>
        <name>SUCCESS</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="1014" column="13" bodyfile="src/hcubature.cpp" bodystart="1014" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="hcubature_8cpp_1a9c1de8d7d3a5f420ee40985f0f7a5bcb" prot="public" static="no" mutable="no">
        <type>bad</type>
        <definition>bad __pad0__</definition>
        <argsstring></argsstring>
        <name>__pad0__</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="1016" column="1" bodyfile="src/hcubature.cpp" bodystart="1017" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="hcubature_8cpp_1a5e8b3ef25c2112d665103be1e3618041" prot="public" static="no" mutable="no">
        <type>return</type>
        <definition>return FAILURE</definition>
        <argsstring></argsstring>
        <name>FAILURE</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="1020" column="13" bodyfile="src/hcubature.cpp" bodystart="1020" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="hcubature_8cpp_1a0d397764923d4999a810624380ab6fca" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>static double errMax</definition>
        <argsstring>(unsigned fdim, const esterr *ee)</argsstring>
        <name>errMax</name>
        <param>
          <type>unsigned</type>
          <declname>fdim</declname>
        </param>
        <param>
          <type>const <ref refid="structesterr" kindref="compound">esterr</ref> *</type>
          <declname>ee</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="119" column="15" bodyfile="src/hcubature.cpp" bodystart="119" bodyend="126"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1a8b1e2bdc348310fd0778c2cabcded918" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>double</type>
        <definition>static double compute_vol</definition>
        <argsstring>(const hypercube *h)</argsstring>
        <name>compute_vol</name>
        <param>
          <type>const <ref refid="structhypercube" kindref="compound">hypercube</ref> *</type>
          <declname>h</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="134" column="15" bodyfile="src/hcubature.cpp" bodystart="134" bodyend="141"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1a8c91dca5838e36ead202ed153bc172e6" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structhypercube" kindref="compound">hypercube</ref></type>
        <definition>static hypercube make_hypercube</definition>
        <argsstring>(unsigned dim, const double *center, const double *halfwidth)</argsstring>
        <name>make_hypercube</name>
        <param>
          <type>unsigned</type>
          <declname>dim</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>center</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>halfwidth</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="143" column="18" bodyfile="src/hcubature.cpp" bodystart="143" bodyend="158"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1a5b71f86b8b069158d58c053fb1b83c4a" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structhypercube" kindref="compound">hypercube</ref></type>
        <definition>static hypercube make_hypercube_range</definition>
        <argsstring>(unsigned dim, const double *xmin, const double *xmax)</argsstring>
        <name>make_hypercube_range</name>
        <param>
          <type>unsigned</type>
          <declname>dim</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>xmin</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>xmax</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="160" column="18" bodyfile="src/hcubature.cpp" bodystart="160" bodyend="172"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1aa497d53794f227d6399ed521f39da116" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void destroy_hypercube</definition>
        <argsstring>(hypercube *h)</argsstring>
        <name>destroy_hypercube</name>
        <param>
          <type><ref refid="structhypercube" kindref="compound">hypercube</ref> *</type>
          <declname>h</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="174" column="13" bodyfile="src/hcubature.cpp" bodystart="174" bodyend="178"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1a121db888d4b0d2534fe6a42bf5af5717" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structregion" kindref="compound">region</ref></type>
        <definition>static region make_region</definition>
        <argsstring>(const hypercube *h, unsigned fdim)</argsstring>
        <name>make_region</name>
        <param>
          <type>const <ref refid="structhypercube" kindref="compound">hypercube</ref> *</type>
          <declname>h</declname>
        </param>
        <param>
          <type>unsigned</type>
          <declname>fdim</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="188" column="15" bodyfile="src/hcubature.cpp" bodystart="188" bodyend="197"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1a1531f878035ec0004a5226202f37d2a3" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void destroy_region</definition>
        <argsstring>(region *R)</argsstring>
        <name>destroy_region</name>
        <param>
          <type><ref refid="structregion" kindref="compound">region</ref> *</type>
          <declname>R</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="199" column="13" bodyfile="src/hcubature.cpp" bodystart="199" bodyend="204"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1a375ae9a2abc77408e0e54ed3437255e5" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int cut_region</definition>
        <argsstring>(region *R, region *R2)</argsstring>
        <name>cut_region</name>
        <param>
          <type><ref refid="structregion" kindref="compound">region</ref> *</type>
          <declname>R</declname>
        </param>
        <param>
          <type><ref refid="structregion" kindref="compound">region</ref> *</type>
          <declname>R2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="206" column="12" bodyfile="src/hcubature.cpp" bodystart="206" bodyend="218"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1a5e67bf3f076c7c367fb07c68f145c026" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void destroy_rule</definition>
        <argsstring>(rule *r)</argsstring>
        <name>destroy_rule</name>
        <param>
          <type><ref refid="structrule__s" kindref="compound">rule</ref> *</type>
          <declname>r</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="238" column="13" bodyfile="src/hcubature.cpp" bodystart="238" bodyend="245"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1ad9b7f7ab56eb484bcb92a803269fc8db" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int alloc_rule_pts</definition>
        <argsstring>(rule *r, unsigned num_regions)</argsstring>
        <name>alloc_rule_pts</name>
        <param>
          <type><ref refid="structrule__s" kindref="compound">rule</ref> *</type>
          <declname>r</declname>
        </param>
        <param>
          <type>unsigned</type>
          <declname>num_regions</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="247" column="12" bodyfile="src/hcubature.cpp" bodystart="247" bodyend="265"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1a2d2959b29882ffe0a44db596fce32832" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structrule__s" kindref="compound">rule</ref> *</type>
        <definition>static rule* make_rule</definition>
        <argsstring>(size_t sz, unsigned dim, unsigned fdim, unsigned num_points, evalError_func evalError, destroy_func destroy)</argsstring>
        <name>make_rule</name>
        <param>
          <type>size_t</type>
          <declname>sz</declname>
        </param>
        <param>
          <type>unsigned</type>
          <declname>dim</declname>
        </param>
        <param>
          <type>unsigned</type>
          <declname>fdim</declname>
        </param>
        <param>
          <type>unsigned</type>
          <declname>num_points</declname>
        </param>
        <param>
          <type>evalError_func</type>
          <declname>evalError</declname>
        </param>
        <param>
          <type>destroy_func</type>
          <declname>destroy</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="267" column="13" bodyfile="src/hcubature.cpp" bodystart="267" bodyend="282"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1a70797ecec60cd903b6d274df1e34a1ee" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int eval_regions</definition>
        <argsstring>(unsigned nR, region *R, integrand_v f, void *fdata, rule *r)</argsstring>
        <name>eval_regions</name>
        <param>
          <type>unsigned</type>
          <declname>nR</declname>
        </param>
        <param>
          <type><ref refid="structregion" kindref="compound">region</ref> *</type>
          <declname>R</declname>
        </param>
        <param>
          <type>integrand_v</type>
          <declname>f</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>fdata</declname>
        </param>
        <param>
          <type><ref refid="structrule__s" kindref="compound">rule</ref> *</type>
          <declname>r</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="285" column="12" bodyfile="src/hcubature.cpp" bodystart="285" bodyend="294"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1abcec210bae0fbdcdaa38a2ffdb744a2a" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>unsigned</type>
        <definition>static unsigned ls0</definition>
        <argsstring>(unsigned n)</argsstring>
        <name>ls0</name>
        <param>
          <type>unsigned</type>
          <declname>n</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="304" column="17" bodyfile="src/hcubature.cpp" bodystart="304" bodyend="335"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1a75f4772bc34dff6bce01589b667db8d7" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void evalR_Rfs</definition>
        <argsstring>(double *pts, unsigned dim, double *p, const double *c, const double *r)</argsstring>
        <name>evalR_Rfs</name>
        <param>
          <type>double *</type>
          <declname>pts</declname>
        </param>
        <param>
          <type>unsigned</type>
          <declname>dim</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>c</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>r</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Evaluate the integration points for all 2^n points (+/-r,...+/-r)</para>
<para>A Gray-code ordering is used to minimize the number of coordinate updates in p, although this doesn&apos;t matter as much now that we are saving all pts. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="343" column="13" bodyfile="src/hcubature.cpp" bodystart="343" bodyend="368"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1a99f331c0c5bfe79b0eeebbdf4c2640cf" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void evalRR0_0fs</definition>
        <argsstring>(double *pts, unsigned dim, double *p, const double *c, const double *r)</argsstring>
        <name>evalRR0_0fs</name>
        <param>
          <type>double *</type>
          <declname>pts</declname>
        </param>
        <param>
          <type>unsigned</type>
          <declname>dim</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>c</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>r</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="370" column="13" bodyfile="src/hcubature.cpp" bodystart="370" bodyend="390"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1ab56049dff0368689e829aab67ef68d14" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void evalR0_0fs4d</definition>
        <argsstring>(double *pts, unsigned dim, double *p, const double *c, const double *r1, const double *r2)</argsstring>
        <name>evalR0_0fs4d</name>
        <param>
          <type>double *</type>
          <declname>pts</declname>
        </param>
        <param>
          <type>unsigned</type>
          <declname>dim</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>p</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>c</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>r1</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>r2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="392" column="13" bodyfile="src/hcubature.cpp" bodystart="392" bodyend="414"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1afefd12958aed13221fb29116bc8beafb" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int isqr</definition>
        <argsstring>(int x)</argsstring>
        <name>isqr</name>
        <param>
          <type>int</type>
          <declname>x</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="445" column="12" bodyfile="src/hcubature.cpp" bodystart="445" bodyend="448"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1ab23e92c8bdc75520b4170ea61f8a18af" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void destroy_rule75genzmalik</definition>
        <argsstring>(rule *r_)</argsstring>
        <name>destroy_rule75genzmalik</name>
        <param>
          <type><ref refid="structrule__s" kindref="compound">rule</ref> *</type>
          <declname>r_</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="450" column="13" bodyfile="src/hcubature.cpp" bodystart="450" bodyend="454"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1a757f26e72d2a0389d62ee2d2137f4f40" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int rule75genzmalik_evalError</definition>
        <argsstring>(rule *r_, unsigned fdim, integrand_v f, void *fdata, unsigned nR, region *R)</argsstring>
        <name>rule75genzmalik_evalError</name>
        <param>
          <type><ref refid="structrule__s" kindref="compound">rule</ref> *</type>
          <declname>r_</declname>
        </param>
        <param>
          <type>unsigned</type>
          <declname>fdim</declname>
        </param>
        <param>
          <type>integrand_v</type>
          <declname>f</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>fdata</declname>
        </param>
        <param>
          <type>unsigned</type>
          <declname>nR</declname>
        </param>
        <param>
          <type><ref refid="structregion" kindref="compound">region</ref> *</type>
          <declname>R</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="456" column="12" bodyfile="src/hcubature.cpp" bodystart="456" bodyend="577"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1aaa9f3d615f5f3be5790fdd3b977d5f7e" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structrule__s" kindref="compound">rule</ref> *</type>
        <definition>static rule* make_rule75genzmalik</definition>
        <argsstring>(unsigned dim, unsigned fdim)</argsstring>
        <name>make_rule75genzmalik</name>
        <param>
          <type>unsigned</type>
          <declname>dim</declname>
        </param>
        <param>
          <type>unsigned</type>
          <declname>fdim</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="579" column="13" bodyfile="src/hcubature.cpp" bodystart="579" bodyend="614"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1a1aadf608c250c4d53ea79011ea19634e" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int rule15gauss_evalError</definition>
        <argsstring>(rule *r, unsigned fdim, integrand_v f, void *fdata, unsigned nR, region *R)</argsstring>
        <name>rule15gauss_evalError</name>
        <param>
          <type><ref refid="structrule__s" kindref="compound">rule</ref> *</type>
          <declname>r</declname>
        </param>
        <param>
          <type>unsigned</type>
          <declname>fdim</declname>
        </param>
        <param>
          <type>integrand_v</type>
          <declname>f</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>fdata</declname>
        </param>
        <param>
          <type>unsigned</type>
          <declname>nR</declname>
        </param>
        <param>
          <type><ref refid="structregion" kindref="compound">region</ref> *</type>
          <declname>R</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="620" column="12" bodyfile="src/hcubature.cpp" bodystart="620" bodyend="757"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1aecf3f198483f652b772c1f384e6decaf" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structrule__s" kindref="compound">rule</ref> *</type>
        <definition>static rule* make_rule15gauss</definition>
        <argsstring>(unsigned dim, unsigned fdim)</argsstring>
        <name>make_rule15gauss</name>
        <param>
          <type>unsigned</type>
          <declname>dim</declname>
        </param>
        <param>
          <type>unsigned</type>
          <declname>fdim</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="759" column="13" bodyfile="src/hcubature.cpp" bodystart="759" bodyend="765"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1a78422adaf8f16e5be3ae832727fef3e2" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void heap_resize</definition>
        <argsstring>(heap *h, size_t nalloc)</argsstring>
        <name>heap_resize</name>
        <param>
          <type><ref refid="structheap" kindref="compound">heap</ref> *</type>
          <declname>h</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>nalloc</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="782" column="13" bodyfile="src/hcubature.cpp" bodystart="782" bodyend="792"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1a270f2254b8958a8f7880fdd2f84d7948" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structheap" kindref="compound">heap</ref></type>
        <definition>static heap heap_alloc</definition>
        <argsstring>(size_t nalloc, unsigned fdim)</argsstring>
        <name>heap_alloc</name>
        <param>
          <type>size_t</type>
          <declname>nalloc</declname>
        </param>
        <param>
          <type>unsigned</type>
          <declname>fdim</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="794" column="13" bodyfile="src/hcubature.cpp" bodystart="794" bodyend="808"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1a84e9e8921c95e1eafddee6824d9e4716" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void heap_free</definition>
        <argsstring>(heap *h)</argsstring>
        <name>heap_free</name>
        <param>
          <type><ref refid="structheap" kindref="compound">heap</ref> *</type>
          <declname>h</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="811" column="13" bodyfile="src/hcubature.cpp" bodystart="811" bodyend="817"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1a7f1c6c8547ee7a3d26e82dc22bdf8061" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int heap_push</definition>
        <argsstring>(heap *h, heap_item hi)</argsstring>
        <name>heap_push</name>
        <param>
          <type><ref refid="structheap" kindref="compound">heap</ref> *</type>
          <declname>h</declname>
        </param>
        <param>
          <type><ref refid="structregion" kindref="compound">heap_item</ref></type>
          <declname>hi</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="819" column="12" bodyfile="src/hcubature.cpp" bodystart="819" bodyend="843"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1ae4ff85c5d39e64a9c39a8e3f40b281a9" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int heap_push_many</definition>
        <argsstring>(heap *h, size_t ni, heap_item *hi)</argsstring>
        <name>heap_push_many</name>
        <param>
          <type><ref refid="structheap" kindref="compound">heap</ref> *</type>
          <declname>h</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>ni</declname>
        </param>
        <param>
          <type><ref refid="structregion" kindref="compound">heap_item</ref> *</type>
          <declname>hi</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="845" column="12" bodyfile="src/hcubature.cpp" bodystart="845" bodyend="851"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1a73d119dd4af44f8a9ef4cdc6815c9668" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structregion" kindref="compound">heap_item</ref></type>
        <definition>static heap_item heap_pop</definition>
        <argsstring>(heap *h)</argsstring>
        <name>heap_pop</name>
        <param>
          <type><ref refid="structheap" kindref="compound">heap</ref> *</type>
          <declname>h</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="853" column="18" bodyfile="src/hcubature.cpp" bodystart="853" bodyend="890"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1abffbf23465d4b5c9df42a6d469a39083" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int converged</definition>
        <argsstring>(unsigned fdim, const esterr *ee, double reqAbsError, double reqRelError, error_norm norm) static int rulecubature(rule *r</argsstring>
        <name>converged</name>
        <param>
          <type>unsigned</type>
          <declname>fdim</declname>
        </param>
        <param>
          <type>const <ref refid="structesterr" kindref="compound">esterr</ref> *</type>
          <declname>ee</declname>
        </param>
        <param>
          <type>double</type>
          <declname>reqAbsError</declname>
        </param>
        <param>
          <type>double</type>
          <declname>reqRelError</declname>
        </param>
        <param>
          <type>error_norm</type>
          <declname>norm</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="894" column="12"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1a37e91582e436a1b80bb541ade27cae6e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>if</definition>
        <argsstring>(fdim&lt;=1) norm</argsstring>
        <name>if</name>
        <param>
          <type>fdim&lt;=</type>
          <declname>1</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="919" column="6" declfile="src/hcubature.cpp" declline="919" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1a98f47dc17f13588c299da762038e71c1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>if</definition>
        <argsstring>(norm&lt; 0||norm &gt; ERROR_LINF) return FAILURE</argsstring>
        <name>if</name>
        <param>
          <type>norm&lt; 0||norm &gt;</type>
          <declname>ERROR_LINF</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="920" column="6" declfile="src/hcubature.cpp" declline="920" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1af3ee6c55007bc4ebc7dff86288016575" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>if</definition>
        <argsstring>(!regions.ee||!regions.items) goto bad</argsstring>
        <name>if</name>
        <param>
          <type>!regions.ee||!regions.</type>
          <declname>items</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="923" column="6" declfile="src/hcubature.cpp" declline="923" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1a58bc1bef5988ead2aabaf7895badee37" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>if</definition>
        <argsstring>(!ee) goto bad</argsstring>
        <name>if</name>
        <param>
          <type>!</type>
          <declname>ee</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="926" column="6" declfile="src/hcubature.cpp" declline="926" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1a95e408aca2c7ad2ebe9c68dc1eee4a52" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>if</definition>
        <argsstring>(!R[0].ee||eval_regions(1, R, f, fdata, r)||heap_push(&amp;regions, R[0])) goto bad</argsstring>
        <name>if</name>
        <param>
          <type>!R.ee||eval_regions(1, R, f, fdata, r)||heap_push &amp;, [0]</type>
          <declname>R</declname>
          <array>[0]</array>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="932" column="6" declfile="src/hcubature.cpp" declline="932" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1a031cf79bdb7e33f7b3e57ba0383c8bb9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>while</definition>
        <argsstring>(numEval&lt; maxEval||!maxEval)</argsstring>
        <name>while</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="938" column="6" bodyfile="src/hcubature.cpp" bodystart="938" bodyend="998"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1a7be0be7a3c84472ca5f9efd574d7457b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>for</definition>
        <argsstring>(j=0;j&lt; fdim;++j) val[j]</argsstring>
        <name>for</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="1002" column="6" bodyfile="src/hcubature.cpp" bodystart="1002" bodyend="1008" declfile="src/hcubature.cpp" declline="1001" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1ab6d346c6c83c24582977c152216fbcac" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>free</definition>
        <argsstring>(ee)</argsstring>
        <name>free</name>
        <param>
          <type>ee</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="1011" column="6" declfile="src/hcubature.cpp" declline="1011" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1a70462968783e3a31779a86972a356d85" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>free</definition>
        <argsstring>(R)</argsstring>
        <name>free</name>
        <param>
          <type>R</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="1013" column="6" declfile="src/hcubature.cpp" declline="1013" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1a0be92ae87c625a7a0c061e210ed4d5f5" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int cubature</definition>
        <argsstring>(unsigned fdim, integrand_v f, void *fdata, unsigned dim, const double *xmin, const double *xmax, size_t maxEval, double reqAbsError, double reqRelError, error_norm norm, double *val, double *err, int parallel)</argsstring>
        <name>cubature</name>
        <param>
          <type>unsigned</type>
          <declname>fdim</declname>
        </param>
        <param>
          <type>integrand_v</type>
          <declname>f</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>fdata</declname>
        </param>
        <param>
          <type>unsigned</type>
          <declname>dim</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>xmin</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>xmax</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>maxEval</declname>
        </param>
        <param>
          <type>double</type>
          <declname>reqAbsError</declname>
        </param>
        <param>
          <type>double</type>
          <declname>reqRelError</declname>
        </param>
        <param>
          <type>error_norm</type>
          <declname>norm</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>val</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>err</declname>
        </param>
        <param>
          <type>int</type>
          <declname>parallel</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="1023" column="12" bodyfile="src/hcubature.cpp" bodystart="1023" bodyend="1057"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1aa662b8ef163a773bad94ba16c3e5abdd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int hcubature_v</definition>
        <argsstring>(unsigned fdim, integrand_v f, void *fdata, unsigned dim, const double *xmin, const double *xmax, size_t maxEval, double reqAbsError, double reqRelError, error_norm norm, double *val, double *err)</argsstring>
        <name>hcubature_v</name>
        <param>
          <type>unsigned</type>
          <declname>fdim</declname>
        </param>
        <param>
          <type>integrand_v</type>
          <declname>f</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>fdata</declname>
        </param>
        <param>
          <type>unsigned</type>
          <declname>dim</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>xmin</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>xmax</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>maxEval</declname>
        </param>
        <param>
          <type>double</type>
          <declname>reqAbsError</declname>
        </param>
        <param>
          <type>double</type>
          <declname>reqRelError</declname>
        </param>
        <param>
          <type>error_norm</type>
          <declname>norm</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>val</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>err</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="1059" column="5" bodyfile="src/hcubature.cpp" bodystart="1059" bodyend="1067"/>
      </memberdef>
      <memberdef kind="function" id="hcubature_8cpp_1a8917735ee20270de7aafbaeacfab2137" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int hcubature</definition>
        <argsstring>(unsigned fdim, integrand f, void *fdata, unsigned dim, const double *xmin, const double *xmax, size_t maxEval, double reqAbsError, double reqRelError, error_norm norm, double *val, double *err)</argsstring>
        <name>hcubature</name>
        <param>
          <type>unsigned</type>
          <declname>fdim</declname>
        </param>
        <param>
          <type>integrand</type>
          <declname>f</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>fdata</declname>
        </param>
        <param>
          <type>unsigned</type>
          <declname>dim</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>xmin</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>xmax</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>maxEval</declname>
        </param>
        <param>
          <type>double</type>
          <declname>reqAbsError</declname>
        </param>
        <param>
          <type>double</type>
          <declname>reqRelError</declname>
        </param>
        <param>
          <type>error_norm</type>
          <declname>norm</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>val</declname>
        </param>
        <param>
          <type>double *</type>
          <declname>err</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/hcubature.cpp" line="1071" column="5" bodyfile="src/hcubature.cpp" bodystart="1071" bodyend="1086"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="comment">/*<sp/>Adaptive<sp/>multidimensional<sp/>integration<sp/>of<sp/>a<sp/>vector<sp/>of<sp/>integrands.</highlight></codeline>
<codeline lineno="2"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="3"><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(c)<sp/>2005-2013<sp/>Steven<sp/>G.<sp/>Johnson</highlight></codeline>
<codeline lineno="4"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="5"><highlight class="comment"><sp/>*<sp/>Portions<sp/>(see<sp/>comments)<sp/>based<sp/>on<sp/>HIntLib<sp/>(also<sp/>distributed<sp/>under</highlight></codeline>
<codeline lineno="6"><highlight class="comment"><sp/>*<sp/>the<sp/>GNU<sp/>GPL,<sp/>v2<sp/>or<sp/>later),<sp/>copyright<sp/>(c)<sp/>2002-2005<sp/>Rudolf<sp/>Schuerer.</highlight></codeline>
<codeline lineno="7"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>(http://www.cosy.sbg.ac.at/~rschuer/hintlib/)</highlight></codeline>
<codeline lineno="8"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="9"><highlight class="comment"><sp/>*<sp/>Portions<sp/>(see<sp/>comments)<sp/>based<sp/>on<sp/>GNU<sp/>GSL<sp/>(also<sp/>distributed<sp/>under</highlight></codeline>
<codeline lineno="10"><highlight class="comment"><sp/>*<sp/>the<sp/>GNU<sp/>GPL,<sp/>v2<sp/>or<sp/>later),<sp/>copyright<sp/>(c)<sp/>1996-2000<sp/>Brian<sp/>Gough.</highlight></codeline>
<codeline lineno="11"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>(http://www.gnu.org/software/gsl/)</highlight></codeline>
<codeline lineno="12"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="13"><highlight class="comment"><sp/>*<sp/>This<sp/>program<sp/>is<sp/>free<sp/>software;<sp/>you<sp/>can<sp/>redistribute<sp/>it<sp/>and/or<sp/>modify</highlight></codeline>
<codeline lineno="14"><highlight class="comment"><sp/>*<sp/>it<sp/>under<sp/>the<sp/>terms<sp/>of<sp/>the<sp/>GNU<sp/>General<sp/>Public<sp/>License<sp/>as<sp/>published<sp/>by</highlight></codeline>
<codeline lineno="15"><highlight class="comment"><sp/>*<sp/>the<sp/>Free<sp/>Software<sp/>Foundation;<sp/>either<sp/>version<sp/>2<sp/>of<sp/>the<sp/>License,<sp/>or</highlight></codeline>
<codeline lineno="16"><highlight class="comment"><sp/>*<sp/>(at<sp/>your<sp/>option)<sp/>any<sp/>later<sp/>version.</highlight></codeline>
<codeline lineno="17"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="18"><highlight class="comment"><sp/>*<sp/>This<sp/>program<sp/>is<sp/>distributed<sp/>in<sp/>the<sp/>hope<sp/>that<sp/>it<sp/>will<sp/>be<sp/>useful,</highlight></codeline>
<codeline lineno="19"><highlight class="comment"><sp/>*<sp/>but<sp/>WITHOUT<sp/>ANY<sp/>WARRANTY;<sp/>without<sp/>even<sp/>the<sp/>implied<sp/>warranty<sp/>of</highlight></codeline>
<codeline lineno="20"><highlight class="comment"><sp/>*<sp/>MERCHANTABILITY<sp/>or<sp/>FITNESS<sp/>FOR<sp/>A<sp/>PARTICULAR<sp/>PURPOSE.<sp/><sp/>See<sp/>the</highlight></codeline>
<codeline lineno="21"><highlight class="comment"><sp/>*<sp/>GNU<sp/>General<sp/>Public<sp/>License<sp/>for<sp/>more<sp/>details.</highlight></codeline>
<codeline lineno="22"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="23"><highlight class="comment"><sp/>*<sp/>You<sp/>should<sp/>have<sp/>received<sp/>a<sp/>copy<sp/>of<sp/>the<sp/>GNU<sp/>General<sp/>Public<sp/>License</highlight></codeline>
<codeline lineno="24"><highlight class="comment"><sp/>*<sp/>along<sp/>with<sp/>this<sp/>program;<sp/>if<sp/>not,<sp/>write<sp/>to<sp/>the<sp/>Free<sp/>Software</highlight></codeline>
<codeline lineno="25"><highlight class="comment"><sp/>*<sp/>Foundation,<sp/>Inc.,<sp/>59<sp/>Temple<sp/>Place,<sp/>Suite<sp/>330,<sp/>Boston,<sp/>MA<sp/><sp/>02111-1307<sp/><sp/>USA</highlight></codeline>
<codeline lineno="26"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="27"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="28"><highlight class="normal"></highlight></codeline>
<codeline lineno="29"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdio.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="30"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdlib.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="31"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;string.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="32"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;math.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="33"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;limits.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="34"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;float.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="35"><highlight class="normal"></highlight></codeline>
<codeline lineno="36"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Adaptive<sp/>multidimensional<sp/>integration<sp/>on<sp/>hypercubes<sp/>(or,<sp/>really,</highlight></codeline>
<codeline lineno="37"><highlight class="comment"><sp/><sp/><sp/>hyper-rectangles)<sp/>using<sp/>cubature<sp/>rules.</highlight></codeline>
<codeline lineno="38"><highlight class="comment"></highlight></codeline>
<codeline lineno="39"><highlight class="comment"><sp/><sp/><sp/>A<sp/>cubature<sp/>rule<sp/>takes<sp/>a<sp/>function<sp/>and<sp/>a<sp/>hypercube<sp/>and<sp/>evaluates</highlight></codeline>
<codeline lineno="40"><highlight class="comment"><sp/><sp/><sp/>the<sp/>function<sp/>at<sp/>a<sp/>small<sp/>number<sp/>of<sp/>points,<sp/>returning<sp/>an<sp/>estimate</highlight></codeline>
<codeline lineno="41"><highlight class="comment"><sp/><sp/><sp/>of<sp/>the<sp/>integral<sp/>as<sp/>well<sp/>as<sp/>an<sp/>estimate<sp/>of<sp/>the<sp/>error,<sp/>and<sp/>also</highlight></codeline>
<codeline lineno="42"><highlight class="comment"><sp/><sp/><sp/>a<sp/>suggested<sp/>dimension<sp/>of<sp/>the<sp/>hypercube<sp/>to<sp/>subdivide.</highlight></codeline>
<codeline lineno="43"><highlight class="comment"></highlight></codeline>
<codeline lineno="44"><highlight class="comment"><sp/><sp/><sp/>Given<sp/>such<sp/>a<sp/>rule,<sp/>the<sp/>adaptive<sp/>integration<sp/>is<sp/>simple:</highlight></codeline>
<codeline lineno="45"><highlight class="comment"></highlight></codeline>
<codeline lineno="46"><highlight class="comment"><sp/><sp/><sp/>1)<sp/>Evaluate<sp/>the<sp/>cubature<sp/>rule<sp/>on<sp/>the<sp/>hypercube(s).</highlight></codeline>
<codeline lineno="47"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>Stop<sp/>if<sp/>converged.</highlight></codeline>
<codeline lineno="48"><highlight class="comment"></highlight></codeline>
<codeline lineno="49"><highlight class="comment"><sp/><sp/><sp/>2)<sp/>Pick<sp/>the<sp/>hypercube<sp/>with<sp/>the<sp/>largest<sp/>estimated<sp/>error,</highlight></codeline>
<codeline lineno="50"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>and<sp/>divide<sp/>it<sp/>in<sp/>two<sp/>along<sp/>the<sp/>suggested<sp/>dimension.</highlight></codeline>
<codeline lineno="51"><highlight class="comment"></highlight></codeline>
<codeline lineno="52"><highlight class="comment"><sp/><sp/><sp/>3)<sp/>Goto<sp/>(1).</highlight></codeline>
<codeline lineno="53"><highlight class="comment"></highlight></codeline>
<codeline lineno="54"><highlight class="comment"><sp/>The<sp/>basic<sp/>algorithm<sp/>is<sp/>based<sp/>on<sp/>the<sp/>adaptive<sp/>cubature<sp/>described<sp/>in</highlight></codeline>
<codeline lineno="55"><highlight class="comment"><sp/></highlight></codeline>
<codeline lineno="56"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>A.<sp/>C.<sp/>Genz<sp/>and<sp/>A.<sp/>A.<sp/>Malik,<sp/>&quot;An<sp/>adaptive<sp/>algorithm<sp/>for<sp/>numeric</highlight></codeline>
<codeline lineno="57"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>integration<sp/>over<sp/>an<sp/>N-dimensional<sp/>rectangular<sp/>region,&quot;</highlight></codeline>
<codeline lineno="58"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>J.<sp/>Comput.<sp/>Appl.<sp/>Math.<sp/>6<sp/>(4),<sp/>295-302<sp/>(1980).</highlight></codeline>
<codeline lineno="59"><highlight class="comment"></highlight></codeline>
<codeline lineno="60"><highlight class="comment"><sp/>and<sp/>subsequently<sp/>extended<sp/>to<sp/>integrating<sp/>a<sp/>vector<sp/>of<sp/>integrands<sp/>in</highlight></codeline>
<codeline lineno="61"><highlight class="comment"></highlight></codeline>
<codeline lineno="62"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>J.<sp/>Berntsen,<sp/>T.<sp/>O.<sp/>Espelid,<sp/>and<sp/>A.<sp/>Genz,<sp/>&quot;An<sp/>adaptive<sp/>algorithm</highlight></codeline>
<codeline lineno="63"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>for<sp/>the<sp/>approximate<sp/>calculation<sp/>of<sp/>multiple<sp/>integrals,&quot;</highlight></codeline>
<codeline lineno="64"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>ACM<sp/>Trans.<sp/>Math.<sp/>Soft.<sp/>17<sp/>(4),<sp/>437-451<sp/>(1991).</highlight></codeline>
<codeline lineno="65"><highlight class="comment"></highlight></codeline>
<codeline lineno="66"><highlight class="comment"><sp/>Note,<sp/>however,<sp/>that<sp/>we<sp/>do<sp/>not<sp/>use<sp/>any<sp/>of<sp/>code<sp/>from<sp/>the<sp/>above<sp/>authors</highlight></codeline>
<codeline lineno="67"><highlight class="comment"><sp/>(in<sp/>part<sp/>because<sp/>their<sp/>code<sp/>is<sp/>Fortran<sp/>77,<sp/>but<sp/>mostly<sp/>because<sp/>it<sp/>is</highlight></codeline>
<codeline lineno="68"><highlight class="comment"><sp/>under<sp/>the<sp/>restrictive<sp/>ACM<sp/>copyright<sp/>license).<sp/><sp/>I<sp/>did<sp/>make<sp/>use<sp/>of<sp/>some</highlight></codeline>
<codeline lineno="69"><highlight class="comment"><sp/>GPL<sp/>code<sp/>from<sp/>Rudolf<sp/>Schuerer&apos;s<sp/>HIntLib<sp/>and<sp/>from<sp/>the<sp/>GNU<sp/>Scientific</highlight></codeline>
<codeline lineno="70"><highlight class="comment"><sp/>Library<sp/>as<sp/>listed<sp/>in<sp/>the<sp/>copyright<sp/>notice<sp/>above,<sp/>on<sp/>the<sp/>other<sp/>hand.</highlight></codeline>
<codeline lineno="71"><highlight class="comment"></highlight></codeline>
<codeline lineno="72"><highlight class="comment"><sp/>I<sp/>am<sp/>also<sp/>grateful<sp/>to<sp/>Dmitry<sp/>Turbiner<sp/>&lt;dturbiner@alum.mit.edu&gt;,<sp/>who</highlight></codeline>
<codeline lineno="73"><highlight class="comment"><sp/>implemented<sp/>an<sp/>initial<sp/>prototype<sp/>of<sp/>the<sp/>&quot;vectorized&quot;<sp/>functionality</highlight></codeline>
<codeline lineno="74"><highlight class="comment"><sp/>for<sp/>evaluating<sp/>multiple<sp/>points<sp/>in<sp/>a<sp/>single<sp/>call<sp/>(as<sp/>opposed<sp/>to</highlight></codeline>
<codeline lineno="75"><highlight class="comment"><sp/>multiple<sp/>functions<sp/>in<sp/>a<sp/>single<sp/>call).<sp/><sp/>(Although<sp/>Dmitry<sp/>implemented</highlight></codeline>
<codeline lineno="76"><highlight class="comment"><sp/>a<sp/>working<sp/>version,<sp/>I<sp/>ended<sp/>up<sp/>re-implementing<sp/>this<sp/>feature<sp/>from</highlight></codeline>
<codeline lineno="77"><highlight class="comment"><sp/>scratch<sp/>as<sp/>part<sp/>of<sp/>a<sp/>larger<sp/>code-cleanup,<sp/>and<sp/>in<sp/>order<sp/>to<sp/>have</highlight></codeline>
<codeline lineno="78"><highlight class="comment"><sp/>a<sp/>single<sp/>code<sp/>path<sp/>for<sp/>the<sp/>vectorized<sp/>and<sp/>non-vectorized<sp/>APIs.<sp/><sp/>I</highlight></codeline>
<codeline lineno="79"><highlight class="comment"><sp/>subsequently<sp/>implemented<sp/>the<sp/>algorithm<sp/>by<sp/>Gladwell<sp/>to<sp/>extract</highlight></codeline>
<codeline lineno="80"><highlight class="comment"><sp/>even<sp/>more<sp/>parallelism<sp/>by<sp/>evalutating<sp/>many<sp/>hypercubes<sp/>at<sp/>once.)</highlight></codeline>
<codeline lineno="81"><highlight class="comment"></highlight></codeline>
<codeline lineno="82"><highlight class="comment"><sp/>TODO:</highlight></codeline>
<codeline lineno="83"><highlight class="comment"></highlight></codeline>
<codeline lineno="84"><highlight class="comment"><sp/><sp/><sp/>*<sp/>Putting<sp/>these<sp/>routines<sp/>into<sp/>the<sp/>GNU<sp/>GSL<sp/>library<sp/>would<sp/>be<sp/>nice.</highlight></codeline>
<codeline lineno="85"><highlight class="comment"></highlight></codeline>
<codeline lineno="86"><highlight class="comment"><sp/><sp/><sp/>*<sp/>A<sp/>Python<sp/>interface<sp/>would<sp/>be<sp/>nice.<sp/><sp/>(Also<sp/>a<sp/>Matlab<sp/>interface,</highlight></codeline>
<codeline lineno="87"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>a<sp/>GNU<sp/>Octave<sp/>interface,<sp/>...)</highlight></codeline>
<codeline lineno="88"><highlight class="comment"></highlight></codeline>
<codeline lineno="89"><highlight class="comment"><sp/><sp/><sp/>*<sp/>For<sp/>high-dimensional<sp/>integrals,<sp/>it<sp/>would<sp/>be<sp/>nice<sp/>to<sp/>implement</highlight></codeline>
<codeline lineno="90"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>a<sp/>sparse-grid<sp/>cubature<sp/>scheme<sp/>using<sp/>Clenshaw-Curtis<sp/>quadrature.</highlight></codeline>
<codeline lineno="91"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>Currently,<sp/>for<sp/>dimensions<sp/>&gt;<sp/>7<sp/>or<sp/>so,<sp/>quasi<sp/>Monte<sp/>Carlo<sp/>methods<sp/>win.</highlight></codeline>
<codeline lineno="92"><highlight class="comment"></highlight></codeline>
<codeline lineno="93"><highlight class="comment"><sp/><sp/><sp/>*<sp/>Berntsen<sp/>et.<sp/>al<sp/>also<sp/>describe<sp/>a<sp/>&quot;two-level&quot;<sp/>error<sp/>estimation<sp/>scheme</highlight></codeline>
<codeline lineno="94"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>that<sp/>they<sp/>claim<sp/>makes<sp/>the<sp/>algorithm<sp/>more<sp/>robust.<sp/><sp/>It<sp/>might<sp/>be</highlight></codeline>
<codeline lineno="95"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>nice<sp/>to<sp/>implement<sp/>this,<sp/>at<sp/>least<sp/>as<sp/>an<sp/>option<sp/>(although<sp/>I<sp/>seem</highlight></codeline>
<codeline lineno="96"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>to<sp/>remember<sp/>trying<sp/>it<sp/>once<sp/>and<sp/>it<sp/>made<sp/>the<sp/>number<sp/>of<sp/>evaluations</highlight></codeline>
<codeline lineno="97"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>substantially<sp/>worse<sp/>for<sp/>my<sp/>test<sp/>integrands).</highlight></codeline>
<codeline lineno="98"><highlight class="comment"></highlight></codeline>
<codeline lineno="99"><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="100"><highlight class="normal"></highlight></codeline>
<codeline lineno="101"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>USAGE:<sp/>Call<sp/>cubature<sp/>with<sp/>your<sp/>function<sp/>as<sp/>described<sp/>in<sp/>cubature.h.</highlight></codeline>
<codeline lineno="102"><highlight class="comment"></highlight></codeline>
<codeline lineno="103"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>To<sp/>compile<sp/>a<sp/>test<sp/>program,<sp/>compile<sp/>cubature.c<sp/>with</highlight></codeline>
<codeline lineno="104"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/>-DTEST_INTEGRATOR<sp/>as<sp/>described<sp/>at<sp/>the<sp/>end.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="105"><highlight class="normal"></highlight></codeline>
<codeline lineno="106"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;cubature.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="107"><highlight class="normal"></highlight></codeline>
<codeline lineno="108"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>error<sp/>return<sp/>codes<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="109"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>SUCCESS<sp/>0</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="110"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>FAILURE<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="111"><highlight class="normal"></highlight></codeline>
<codeline lineno="112"><highlight class="normal"></highlight><highlight class="comment">/***************************************************************************/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="113"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Basic<sp/>datatypes<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="114"><highlight class="normal"></highlight></codeline>
<codeline lineno="115" refid="structesterr" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="116"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>val,<sp/>err;</highlight></codeline>
<codeline lineno="117"><highlight class="normal">}<sp/><ref refid="structesterr" kindref="compound">esterr</ref>;</highlight></codeline>
<codeline lineno="118"><highlight class="normal"></highlight></codeline>
<codeline lineno="119"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>errMax(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>fdim,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structesterr" kindref="compound">esterr</ref><sp/>*ee)</highlight></codeline>
<codeline lineno="120"><highlight class="normal">{</highlight></codeline>
<codeline lineno="121"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>errmax<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="122"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>k;</highlight></codeline>
<codeline lineno="123"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(k<sp/>=<sp/>0;<sp/>k<sp/>&lt;<sp/>fdim;<sp/>++k)</highlight></codeline>
<codeline lineno="124"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ee[k].err<sp/>&gt;<sp/>errmax)<sp/>errmax<sp/>=<sp/>ee[k].err;</highlight></codeline>
<codeline lineno="125"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>errmax;</highlight></codeline>
<codeline lineno="126"><highlight class="normal">}</highlight></codeline>
<codeline lineno="127"><highlight class="normal"></highlight></codeline>
<codeline lineno="128" refid="structhypercube" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="129"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>dim;</highlight></codeline>
<codeline lineno="130"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*data;<sp/><sp/></highlight><highlight class="comment">/*<sp/>length<sp/>2*dim<sp/>=<sp/>center<sp/>followed<sp/>by<sp/>half-widths<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="131"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>vol;<sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>cache<sp/>volume<sp/>=<sp/>product<sp/>of<sp/>widths<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="132"><highlight class="normal">}<sp/><ref refid="structhypercube" kindref="compound">hypercube</ref>;</highlight></codeline>
<codeline lineno="133"><highlight class="normal"></highlight></codeline>
<codeline lineno="134"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>compute_vol(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structhypercube" kindref="compound">hypercube</ref><sp/>*h)</highlight></codeline>
<codeline lineno="135"><highlight class="normal">{</highlight></codeline>
<codeline lineno="136"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>i;</highlight></codeline>
<codeline lineno="137"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>vol<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="138"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>h-&gt;dim;<sp/>++i)</highlight></codeline>
<codeline lineno="139"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>vol<sp/>*=<sp/>2<sp/>*<sp/>h-&gt;data[i<sp/>+<sp/>h-&gt;dim];</highlight></codeline>
<codeline lineno="140"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>vol;</highlight></codeline>
<codeline lineno="141"><highlight class="normal">}</highlight></codeline>
<codeline lineno="142"><highlight class="normal"></highlight></codeline>
<codeline lineno="143"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="structhypercube" kindref="compound">hypercube</ref><sp/>make_hypercube(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>dim,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*center,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*halfwidth)</highlight></codeline>
<codeline lineno="144"><highlight class="normal">{</highlight></codeline>
<codeline lineno="145"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>i;</highlight></codeline>
<codeline lineno="146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><ref refid="structhypercube" kindref="compound">hypercube</ref><sp/>h;</highlight></codeline>
<codeline lineno="147"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>h.dim<sp/>=<sp/>dim;</highlight></codeline>
<codeline lineno="148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>h.data<sp/>=<sp/>(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*)<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">)<sp/>*<sp/>dim<sp/>*<sp/>2);</highlight></codeline>
<codeline lineno="149"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>h.vol<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="150"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(h.data)<sp/>{</highlight></codeline>
<codeline lineno="151"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>dim;<sp/>++i)<sp/>{</highlight></codeline>
<codeline lineno="152"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>h.data[i]<sp/>=<sp/>center[i];</highlight></codeline>
<codeline lineno="153"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>h.data[i<sp/>+<sp/>dim]<sp/>=<sp/>halfwidth[i];</highlight></codeline>
<codeline lineno="154"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="155"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>h.vol<sp/>=<sp/>compute_vol(&amp;h);</highlight></codeline>
<codeline lineno="156"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="157"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>h;</highlight></codeline>
<codeline lineno="158"><highlight class="normal">}</highlight></codeline>
<codeline lineno="159"><highlight class="normal"></highlight></codeline>
<codeline lineno="160"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="structhypercube" kindref="compound">hypercube</ref><sp/>make_hypercube_range(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>dim,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*xmin,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*xmax)</highlight></codeline>
<codeline lineno="161"><highlight class="normal">{</highlight></codeline>
<codeline lineno="162"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><ref refid="structhypercube" kindref="compound">hypercube</ref><sp/>h<sp/>=<sp/>make_hypercube(dim,<sp/>xmin,<sp/>xmax);</highlight></codeline>
<codeline lineno="163"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>i;</highlight></codeline>
<codeline lineno="164"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(h.data)<sp/>{</highlight></codeline>
<codeline lineno="165"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>dim;<sp/>++i)<sp/>{</highlight></codeline>
<codeline lineno="166"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>h.data[i]<sp/>=<sp/>0.5<sp/>*<sp/>(xmin[i]<sp/>+<sp/>xmax[i]);</highlight></codeline>
<codeline lineno="167"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>h.data[i<sp/>+<sp/>dim]<sp/>=<sp/>0.5<sp/>*<sp/>(xmax[i]<sp/>-<sp/>xmin[i]);</highlight></codeline>
<codeline lineno="168"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="169"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>h.vol<sp/>=<sp/>compute_vol(&amp;h);</highlight></codeline>
<codeline lineno="170"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="171"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>h;</highlight></codeline>
<codeline lineno="172"><highlight class="normal">}</highlight></codeline>
<codeline lineno="173"><highlight class="normal"></highlight></codeline>
<codeline lineno="174"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>destroy_hypercube(<ref refid="structhypercube" kindref="compound">hypercube</ref><sp/>*h)</highlight></codeline>
<codeline lineno="175"><highlight class="normal">{</highlight></codeline>
<codeline lineno="176"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>free(h-&gt;data);</highlight></codeline>
<codeline lineno="177"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>h-&gt;dim<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="178"><highlight class="normal">}</highlight></codeline>
<codeline lineno="179"><highlight class="normal"></highlight></codeline>
<codeline lineno="180" refid="structregion" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="181"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><ref refid="structhypercube" kindref="compound">hypercube</ref><sp/>h;</highlight></codeline>
<codeline lineno="182"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>splitDim;</highlight></codeline>
<codeline lineno="183"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>fdim;<sp/></highlight><highlight class="comment">/*<sp/>dimensionality<sp/>of<sp/>vector<sp/>integrand<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="184"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><ref refid="structesterr" kindref="compound">esterr</ref><sp/>*ee;<sp/></highlight><highlight class="comment">/*<sp/>array<sp/>of<sp/>length<sp/>fdim<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="185"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>errmax;<sp/></highlight><highlight class="comment">/*<sp/>max<sp/>ee[k].err<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="186"><highlight class="normal">}<sp/><ref refid="structregion" kindref="compound">region</ref>;</highlight></codeline>
<codeline lineno="187"><highlight class="normal"></highlight></codeline>
<codeline lineno="188"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="structregion" kindref="compound">region</ref><sp/>make_region(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structhypercube" kindref="compound">hypercube</ref><sp/>*h,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>fdim)</highlight></codeline>
<codeline lineno="189"><highlight class="normal">{</highlight></codeline>
<codeline lineno="190"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><ref refid="structregion" kindref="compound">region</ref><sp/>R;</highlight></codeline>
<codeline lineno="191"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>R.h<sp/>=<sp/>make_hypercube(h-&gt;dim,<sp/>h-&gt;data,<sp/>h-&gt;data<sp/>+<sp/>h-&gt;dim);</highlight></codeline>
<codeline lineno="192"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>R.splitDim<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="193"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>R.fdim<sp/>=<sp/>fdim;</highlight></codeline>
<codeline lineno="194"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>R.ee<sp/>=<sp/>R.h.data<sp/>?<sp/>(<ref refid="structesterr" kindref="compound">esterr</ref><sp/>*)<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="structesterr" kindref="compound">esterr</ref>)<sp/>*<sp/>fdim)<sp/>:<sp/>NULL;</highlight></codeline>
<codeline lineno="195"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>R.errmax<sp/>=<sp/>HUGE_VAL;</highlight></codeline>
<codeline lineno="196"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>R;</highlight></codeline>
<codeline lineno="197"><highlight class="normal">}</highlight></codeline>
<codeline lineno="198"><highlight class="normal"></highlight></codeline>
<codeline lineno="199"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>destroy_region(<ref refid="structregion" kindref="compound">region</ref><sp/>*R)</highlight></codeline>
<codeline lineno="200"><highlight class="normal">{</highlight></codeline>
<codeline lineno="201"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>destroy_hypercube(&amp;R-&gt;h);</highlight></codeline>
<codeline lineno="202"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>free(R-&gt;ee);</highlight></codeline>
<codeline lineno="203"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>R-&gt;ee<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="204"><highlight class="normal">}</highlight></codeline>
<codeline lineno="205"><highlight class="normal"></highlight></codeline>
<codeline lineno="206"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>cut_region(<ref refid="structregion" kindref="compound">region</ref><sp/>*R,<sp/><ref refid="structregion" kindref="compound">region</ref><sp/>*R2)</highlight></codeline>
<codeline lineno="207"><highlight class="normal">{</highlight></codeline>
<codeline lineno="208"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>d<sp/>=<sp/>R-&gt;splitDim,<sp/>dim<sp/>=<sp/>R-&gt;h.dim;</highlight></codeline>
<codeline lineno="209"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>*R2<sp/>=<sp/>*R;</highlight></codeline>
<codeline lineno="210"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>R-&gt;h.data[d<sp/>+<sp/>dim]<sp/>*=<sp/>0.5;</highlight></codeline>
<codeline lineno="211"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>R-&gt;h.vol<sp/>*=<sp/>0.5;</highlight></codeline>
<codeline lineno="212"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>R2-&gt;h<sp/>=<sp/>make_hypercube(dim,<sp/>R-&gt;h.data,<sp/>R-&gt;h.data<sp/>+<sp/>dim);</highlight></codeline>
<codeline lineno="213"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!R2-&gt;h.data)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>FAILURE;</highlight></codeline>
<codeline lineno="214"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>R-&gt;h.data[d]<sp/>-=<sp/>R-&gt;h.data[d<sp/>+<sp/>dim];</highlight></codeline>
<codeline lineno="215"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>R2-&gt;h.data[d]<sp/>+=<sp/>R-&gt;h.data[d<sp/>+<sp/>dim];</highlight></codeline>
<codeline lineno="216"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>R2-&gt;ee<sp/>=<sp/>(<ref refid="structesterr" kindref="compound">esterr</ref><sp/>*)<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="structesterr" kindref="compound">esterr</ref>)<sp/>*<sp/>R2-&gt;fdim);</highlight></codeline>
<codeline lineno="217"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>R2-&gt;ee<sp/>==<sp/>NULL;</highlight></codeline>
<codeline lineno="218"><highlight class="normal">}</highlight></codeline>
<codeline lineno="219"><highlight class="normal"></highlight></codeline>
<codeline lineno="220"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structrule__s" kindref="compound">rule_s</ref>;<sp/></highlight><highlight class="comment">/*<sp/>forward<sp/>declaration<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="221"><highlight class="normal"></highlight></codeline>
<codeline lineno="222"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>int<sp/>(*evalError_func)(</highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structrule__s" kindref="compound">rule_s</ref><sp/>*r,</highlight></codeline>
<codeline lineno="223"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>fdim,<sp/>integrand_v<sp/>f,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*fdata,</highlight></codeline>
<codeline lineno="224"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>nR,<sp/><ref refid="structregion" kindref="compound">region</ref><sp/>*R);</highlight></codeline>
<codeline lineno="225"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/>void<sp/>(*destroy_func)(</highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structrule__s" kindref="compound">rule_s</ref><sp/>*r);</highlight></codeline>
<codeline lineno="226"><highlight class="normal"></highlight></codeline>
<codeline lineno="227"><highlight class="normal"></highlight></codeline>
<codeline lineno="228" refid="structrule__s" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structrule__s" kindref="compound">rule_s</ref><sp/>{</highlight></codeline>
<codeline lineno="229"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>dim,<sp/>fdim;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>the<sp/>dimensionality<sp/>&amp;<sp/>number<sp/>of<sp/>functions<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="230"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>num_points;<sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>number<sp/>of<sp/>evaluation<sp/>points<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="231"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>num_regions;<sp/></highlight><highlight class="comment">/*<sp/>max<sp/>number<sp/>of<sp/>regions<sp/>evaluated<sp/>at<sp/>once<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="232"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*pts;<sp/></highlight><highlight class="comment">/*<sp/>points<sp/>to<sp/>eval:<sp/>num_regions<sp/>*<sp/>num_points<sp/>*<sp/>dim<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="233"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*vals;<sp/></highlight><highlight class="comment">/*<sp/>num_regions<sp/>*<sp/>num_points<sp/>*<sp/>fdim<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="234"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>evalError_func<sp/>evalError;</highlight></codeline>
<codeline lineno="235"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>destroy_func<sp/>destroy;</highlight></codeline>
<codeline lineno="236"><highlight class="normal">}<sp/><ref refid="structrule__s" kindref="compound">rule</ref>;</highlight></codeline>
<codeline lineno="237"><highlight class="normal"></highlight></codeline>
<codeline lineno="238"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>destroy_rule(<ref refid="structrule__s" kindref="compound">rule</ref><sp/>*r)</highlight></codeline>
<codeline lineno="239"><highlight class="normal">{</highlight></codeline>
<codeline lineno="240"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(r)<sp/>{</highlight></codeline>
<codeline lineno="241"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(r-&gt;destroy)<sp/>r-&gt;destroy(r);</highlight></codeline>
<codeline lineno="242"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>free(r-&gt;pts);</highlight></codeline>
<codeline lineno="243"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>free(r);</highlight></codeline>
<codeline lineno="244"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="245"><highlight class="normal">}</highlight></codeline>
<codeline lineno="246"><highlight class="normal"></highlight></codeline>
<codeline lineno="247"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>alloc_rule_pts(<ref refid="structrule__s" kindref="compound">rule</ref><sp/>*r,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>num_regions)</highlight></codeline>
<codeline lineno="248"><highlight class="normal">{</highlight></codeline>
<codeline lineno="249"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(num_regions<sp/>&gt;<sp/>r-&gt;num_regions)<sp/>{</highlight></codeline>
<codeline lineno="250"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>free(r-&gt;pts);</highlight></codeline>
<codeline lineno="251"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>r-&gt;pts<sp/>=<sp/>r-&gt;vals<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="252"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>r-&gt;num_regions<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="253"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>num_regions<sp/>*=<sp/>2;<sp/></highlight><highlight class="comment">/*<sp/>allocate<sp/>extra<sp/>so<sp/>that</highlight></codeline>
<codeline lineno="254"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>repeatedly<sp/>calling<sp/>alloc_rule_pts<sp/>with</highlight></codeline>
<codeline lineno="255"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>growing<sp/>num_regions<sp/>only<sp/>needs</highlight></codeline>
<codeline lineno="256"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>a<sp/>logarithmic<sp/>number<sp/>of<sp/>allocations<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="257"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>r-&gt;pts<sp/>=<sp/>(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*)<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">)<sp/>*<sp/></highlight></codeline>
<codeline lineno="258"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(num_regions</highlight></codeline>
<codeline lineno="259"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>r-&gt;num_points<sp/>*<sp/>(r-&gt;dim<sp/>+<sp/>r-&gt;fdim)));</highlight></codeline>
<codeline lineno="260"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(r-&gt;fdim<sp/>+<sp/>r-&gt;dim<sp/>&gt;<sp/>0<sp/>&amp;&amp;<sp/>!r-&gt;pts)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>FAILURE;</highlight></codeline>
<codeline lineno="261"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>r-&gt;vals<sp/>=<sp/>r-&gt;pts<sp/>+<sp/>num_regions<sp/>*<sp/>r-&gt;num_points<sp/>*<sp/>r-&gt;dim;</highlight></codeline>
<codeline lineno="262"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>r-&gt;num_regions<sp/>=<sp/>num_regions;</highlight></codeline>
<codeline lineno="263"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="264"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>SUCCESS;</highlight></codeline>
<codeline lineno="265"><highlight class="normal">}</highlight></codeline>
<codeline lineno="266"><highlight class="normal"></highlight></codeline>
<codeline lineno="267"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="structrule__s" kindref="compound">rule</ref><sp/>*make_rule(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>sz,<sp/></highlight><highlight class="comment">/*<sp/>&gt;=<sp/>sizeof(rule)<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="268"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>dim,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>fdim,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>num_points,</highlight></codeline>
<codeline lineno="269"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>evalError_func<sp/>evalError,<sp/>destroy_func<sp/>destroy)</highlight></codeline>
<codeline lineno="270"><highlight class="normal">{</highlight></codeline>
<codeline lineno="271"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><ref refid="structrule__s" kindref="compound">rule</ref><sp/>*r;</highlight></codeline>
<codeline lineno="272"><highlight class="normal"></highlight></codeline>
<codeline lineno="273"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(sz<sp/>&lt;<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="structrule__s" kindref="compound">rule</ref>))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="274"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>r<sp/>=<sp/>(<ref refid="structrule__s" kindref="compound">rule</ref><sp/>*)<sp/>malloc(sz);</highlight></codeline>
<codeline lineno="275"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!r)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="276"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>r-&gt;pts<sp/>=<sp/>r-&gt;vals<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="277"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>r-&gt;num_regions<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="278"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>r-&gt;dim<sp/>=<sp/>dim;<sp/>r-&gt;fdim<sp/>=<sp/>fdim;<sp/>r-&gt;num_points<sp/>=<sp/>num_points;</highlight></codeline>
<codeline lineno="279"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>r-&gt;evalError<sp/>=<sp/>evalError;</highlight></codeline>
<codeline lineno="280"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>r-&gt;destroy<sp/>=<sp/>destroy;</highlight></codeline>
<codeline lineno="281"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>r;</highlight></codeline>
<codeline lineno="282"><highlight class="normal">}</highlight></codeline>
<codeline lineno="283"><highlight class="normal"></highlight></codeline>
<codeline lineno="284"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>note:<sp/>all<sp/>regions<sp/>must<sp/>have<sp/>same<sp/>fdim<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="285"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>eval_regions(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>nR,<sp/><ref refid="structregion" kindref="compound">region</ref><sp/>*R,<sp/></highlight></codeline>
<codeline lineno="286"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>integrand_v<sp/>f,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*fdata,<sp/><ref refid="structrule__s" kindref="compound">rule</ref><sp/>*r)</highlight></codeline>
<codeline lineno="287"><highlight class="normal">{</highlight></codeline>
<codeline lineno="288"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>iR;</highlight></codeline>
<codeline lineno="289"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nR<sp/>==<sp/>0)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>SUCCESS;<sp/></highlight><highlight class="comment">/*<sp/>nothing<sp/>to<sp/>evaluate<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="290"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(r-&gt;evalError(r,<sp/>R-&gt;fdim,<sp/>f,<sp/>fdata,<sp/>nR,<sp/>R))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>FAILURE;</highlight></codeline>
<codeline lineno="291"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(iR<sp/>=<sp/>0;<sp/>iR<sp/>&lt;<sp/>nR;<sp/>++iR)</highlight></codeline>
<codeline lineno="292"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>R[iR].errmax<sp/>=<sp/>errMax(R-&gt;fdim,<sp/>R[iR].ee);</highlight></codeline>
<codeline lineno="293"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>SUCCESS;</highlight></codeline>
<codeline lineno="294"><highlight class="normal">}</highlight></codeline>
<codeline lineno="295"><highlight class="normal"></highlight></codeline>
<codeline lineno="296"><highlight class="normal"></highlight><highlight class="comment">/***************************************************************************/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="297"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Functions<sp/>to<sp/>loop<sp/>over<sp/>points<sp/>in<sp/>a<sp/>hypercube.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="298"><highlight class="normal"></highlight></codeline>
<codeline lineno="299"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Based<sp/>on<sp/>orbitrule.cpp<sp/>in<sp/>HIntLib-0.0.10<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="300"><highlight class="normal"></highlight></codeline>
<codeline lineno="301"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>ls0<sp/>returns<sp/>the<sp/>least-significant<sp/>0<sp/>bit<sp/>of<sp/>n<sp/>(e.g.<sp/>it<sp/>returns</highlight></codeline>
<codeline lineno="302"><highlight class="comment"><sp/><sp/><sp/>0<sp/>if<sp/>the<sp/>LSB<sp/>is<sp/>0,<sp/>it<sp/>returns<sp/>1<sp/>if<sp/>the<sp/>2<sp/>LSBs<sp/>are<sp/>01,<sp/>etcetera).<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="303"><highlight class="normal"></highlight></codeline>
<codeline lineno="304"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>ls0(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>n)</highlight></codeline>
<codeline lineno="305"><highlight class="normal">{</highlight></codeline>
<codeline lineno="306"><highlight class="normal"></highlight><highlight class="preprocessor">#if<sp/>defined(__GNUC__)<sp/>&amp;&amp;<sp/>\</highlight></codeline>
<codeline lineno="307"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>((__GNUC__<sp/>==<sp/>3<sp/>&amp;&amp;<sp/>__GNUC_MINOR__<sp/>&gt;=<sp/>4)<sp/>||<sp/>__GNUC__<sp/>&gt;<sp/>3)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="308"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>__builtin_ctz(~n);<sp/></highlight><highlight class="comment">/*<sp/>gcc<sp/>builtin<sp/>for<sp/>version<sp/>&gt;=<sp/>3.4<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="309"><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="310"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>bits[256]<sp/>=<sp/>{</highlight></codeline>
<codeline lineno="311"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0,<sp/>1,<sp/>0,<sp/>2,<sp/>0,<sp/>1,<sp/>0,<sp/>3,<sp/>0,<sp/>1,<sp/>0,<sp/>2,<sp/>0,<sp/>1,<sp/>0,<sp/>4,</highlight></codeline>
<codeline lineno="312"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0,<sp/>1,<sp/>0,<sp/>2,<sp/>0,<sp/>1,<sp/>0,<sp/>3,<sp/>0,<sp/>1,<sp/>0,<sp/>2,<sp/>0,<sp/>1,<sp/>0,<sp/>5,</highlight></codeline>
<codeline lineno="313"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0,<sp/>1,<sp/>0,<sp/>2,<sp/>0,<sp/>1,<sp/>0,<sp/>3,<sp/>0,<sp/>1,<sp/>0,<sp/>2,<sp/>0,<sp/>1,<sp/>0,<sp/>4,</highlight></codeline>
<codeline lineno="314"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0,<sp/>1,<sp/>0,<sp/>2,<sp/>0,<sp/>1,<sp/>0,<sp/>3,<sp/>0,<sp/>1,<sp/>0,<sp/>2,<sp/>0,<sp/>1,<sp/>0,<sp/>6,</highlight></codeline>
<codeline lineno="315"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0,<sp/>1,<sp/>0,<sp/>2,<sp/>0,<sp/>1,<sp/>0,<sp/>3,<sp/>0,<sp/>1,<sp/>0,<sp/>2,<sp/>0,<sp/>1,<sp/>0,<sp/>4,</highlight></codeline>
<codeline lineno="316"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0,<sp/>1,<sp/>0,<sp/>2,<sp/>0,<sp/>1,<sp/>0,<sp/>3,<sp/>0,<sp/>1,<sp/>0,<sp/>2,<sp/>0,<sp/>1,<sp/>0,<sp/>5,</highlight></codeline>
<codeline lineno="317"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0,<sp/>1,<sp/>0,<sp/>2,<sp/>0,<sp/>1,<sp/>0,<sp/>3,<sp/>0,<sp/>1,<sp/>0,<sp/>2,<sp/>0,<sp/>1,<sp/>0,<sp/>4,</highlight></codeline>
<codeline lineno="318"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0,<sp/>1,<sp/>0,<sp/>2,<sp/>0,<sp/>1,<sp/>0,<sp/>3,<sp/>0,<sp/>1,<sp/>0,<sp/>2,<sp/>0,<sp/>1,<sp/>0,<sp/>7,</highlight></codeline>
<codeline lineno="319"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0,<sp/>1,<sp/>0,<sp/>2,<sp/>0,<sp/>1,<sp/>0,<sp/>3,<sp/>0,<sp/>1,<sp/>0,<sp/>2,<sp/>0,<sp/>1,<sp/>0,<sp/>4,</highlight></codeline>
<codeline lineno="320"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0,<sp/>1,<sp/>0,<sp/>2,<sp/>0,<sp/>1,<sp/>0,<sp/>3,<sp/>0,<sp/>1,<sp/>0,<sp/>2,<sp/>0,<sp/>1,<sp/>0,<sp/>5,</highlight></codeline>
<codeline lineno="321"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0,<sp/>1,<sp/>0,<sp/>2,<sp/>0,<sp/>1,<sp/>0,<sp/>3,<sp/>0,<sp/>1,<sp/>0,<sp/>2,<sp/>0,<sp/>1,<sp/>0,<sp/>4,</highlight></codeline>
<codeline lineno="322"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0,<sp/>1,<sp/>0,<sp/>2,<sp/>0,<sp/>1,<sp/>0,<sp/>3,<sp/>0,<sp/>1,<sp/>0,<sp/>2,<sp/>0,<sp/>1,<sp/>0,<sp/>6,</highlight></codeline>
<codeline lineno="323"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0,<sp/>1,<sp/>0,<sp/>2,<sp/>0,<sp/>1,<sp/>0,<sp/>3,<sp/>0,<sp/>1,<sp/>0,<sp/>2,<sp/>0,<sp/>1,<sp/>0,<sp/>4,</highlight></codeline>
<codeline lineno="324"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0,<sp/>1,<sp/>0,<sp/>2,<sp/>0,<sp/>1,<sp/>0,<sp/>3,<sp/>0,<sp/>1,<sp/>0,<sp/>2,<sp/>0,<sp/>1,<sp/>0,<sp/>5,</highlight></codeline>
<codeline lineno="325"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0,<sp/>1,<sp/>0,<sp/>2,<sp/>0,<sp/>1,<sp/>0,<sp/>3,<sp/>0,<sp/>1,<sp/>0,<sp/>2,<sp/>0,<sp/>1,<sp/>0,<sp/>4,</highlight></codeline>
<codeline lineno="326"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0,<sp/>1,<sp/>0,<sp/>2,<sp/>0,<sp/>1,<sp/>0,<sp/>3,<sp/>0,<sp/>1,<sp/>0,<sp/>2,<sp/>0,<sp/>1,<sp/>0,<sp/>8,</highlight></codeline>
<codeline lineno="327"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="328"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>bit<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="329"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>((n<sp/>&amp;<sp/>0xff)<sp/>==<sp/>0xff)<sp/>{</highlight></codeline>
<codeline lineno="330"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>n<sp/>&gt;&gt;=<sp/>8;</highlight></codeline>
<codeline lineno="331"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>bit<sp/>+=<sp/>8;</highlight></codeline>
<codeline lineno="332"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="333"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>bit<sp/>+<sp/>bits[n<sp/>&amp;<sp/>0xff];</highlight></codeline>
<codeline lineno="334"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="335"><highlight class="normal">}</highlight></codeline>
<codeline lineno="336"><highlight class="normal"></highlight></codeline>
<codeline lineno="343"><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>evalR_Rfs(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*pts,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>dim,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*p,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*c,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*r)</highlight></codeline>
<codeline lineno="344"><highlight class="normal">{</highlight></codeline>
<codeline lineno="345"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>i;</highlight></codeline>
<codeline lineno="346"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>signs<sp/>=<sp/>0;<sp/></highlight><highlight class="comment">/*<sp/>0/1<sp/>bit<sp/>=<sp/>+/-<sp/>for<sp/>corresponding<sp/>element<sp/>of<sp/>r[]<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="347"><highlight class="normal"></highlight></codeline>
<codeline lineno="348"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>We<sp/>start<sp/>with<sp/>the<sp/>point<sp/>where<sp/>r<sp/>is<sp/>ADDed<sp/>in<sp/>every<sp/>coordinate</highlight></codeline>
<codeline lineno="349"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(this<sp/>implies<sp/>signs=0).<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="350"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>dim;<sp/>++i)</highlight></codeline>
<codeline lineno="351"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>p[i]<sp/>=<sp/>c[i]<sp/>+<sp/>r[i];</highlight></codeline>
<codeline lineno="352"><highlight class="normal"></highlight></codeline>
<codeline lineno="353"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Loop<sp/>through<sp/>the<sp/>points<sp/>in<sp/>Gray-code<sp/>ordering<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="354"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;;<sp/>++i)<sp/>{</highlight></codeline>
<codeline lineno="355"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>mask,<sp/>d;</highlight></codeline>
<codeline lineno="356"><highlight class="normal"></highlight></codeline>
<codeline lineno="357"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>memcpy(pts,<sp/>p,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">)<sp/>*<sp/>dim);<sp/>pts<sp/>+=<sp/>dim;</highlight></codeline>
<codeline lineno="358"><highlight class="normal"></highlight></codeline>
<codeline lineno="359"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>d<sp/>=<sp/>ls0(i);<sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>which<sp/>coordinate<sp/>to<sp/>flip<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="360"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(d<sp/>&gt;=<sp/>dim)</highlight></codeline>
<codeline lineno="361"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="362"><highlight class="normal"></highlight></codeline>
<codeline lineno="363"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>flip<sp/>the<sp/>d-th<sp/>bit<sp/>and<sp/>add/subtract<sp/>r[d]<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="364"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>mask<sp/>=<sp/>1U<sp/>&lt;&lt;<sp/>d;</highlight></codeline>
<codeline lineno="365"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>signs<sp/>^=<sp/>mask;</highlight></codeline>
<codeline lineno="366"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>p[d]<sp/>=<sp/>(signs<sp/>&amp;<sp/>mask)<sp/>?<sp/>c[d]<sp/>-<sp/>r[d]<sp/>:<sp/>c[d]<sp/>+<sp/>r[d];</highlight></codeline>
<codeline lineno="367"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="368"><highlight class="normal">}</highlight></codeline>
<codeline lineno="369"><highlight class="normal"></highlight></codeline>
<codeline lineno="370"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>evalRR0_0fs(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*pts,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>dim,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*p,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*c,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*r)</highlight></codeline>
<codeline lineno="371"><highlight class="normal">{</highlight></codeline>
<codeline lineno="372"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>i,<sp/>j;</highlight></codeline>
<codeline lineno="373"><highlight class="normal"></highlight></codeline>
<codeline lineno="374"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>dim<sp/>-<sp/>1;<sp/>++i)<sp/>{</highlight></codeline>
<codeline lineno="375"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>p[i]<sp/>=<sp/>c[i]<sp/>-<sp/>r[i];</highlight></codeline>
<codeline lineno="376"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(j<sp/>=<sp/>i<sp/>+<sp/>1;<sp/>j<sp/>&lt;<sp/>dim;<sp/>++j)<sp/>{</highlight></codeline>
<codeline lineno="377"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p[j]<sp/>=<sp/>c[j]<sp/>-<sp/>r[j];</highlight></codeline>
<codeline lineno="378"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memcpy(pts,<sp/>p,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">)<sp/>*<sp/>dim);<sp/>pts<sp/>+=<sp/>dim;</highlight></codeline>
<codeline lineno="379"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p[i]<sp/>=<sp/>c[i]<sp/>+<sp/>r[i];</highlight></codeline>
<codeline lineno="380"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memcpy(pts,<sp/>p,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">)<sp/>*<sp/>dim);<sp/>pts<sp/>+=<sp/>dim;</highlight></codeline>
<codeline lineno="381"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p[j]<sp/>=<sp/>c[j]<sp/>+<sp/>r[j];</highlight></codeline>
<codeline lineno="382"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memcpy(pts,<sp/>p,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">)<sp/>*<sp/>dim);<sp/>pts<sp/>+=<sp/>dim;</highlight></codeline>
<codeline lineno="383"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p[i]<sp/>=<sp/>c[i]<sp/>-<sp/>r[i];</highlight></codeline>
<codeline lineno="384"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memcpy(pts,<sp/>p,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">)<sp/>*<sp/>dim);<sp/>pts<sp/>+=<sp/>dim;</highlight></codeline>
<codeline lineno="385"><highlight class="normal"></highlight></codeline>
<codeline lineno="386"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p[j]<sp/>=<sp/>c[j];<sp/></highlight><highlight class="comment">/*<sp/>Done<sp/>with<sp/>j<sp/>-&gt;<sp/>Restore<sp/>p[j]<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="387"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="388"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>p[i]<sp/>=<sp/>c[i];<sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Done<sp/>with<sp/>i<sp/>-&gt;<sp/>Restore<sp/>p[i]<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="389"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="390"><highlight class="normal">}</highlight></codeline>
<codeline lineno="391"><highlight class="normal"></highlight></codeline>
<codeline lineno="392"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>evalR0_0fs4d(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*pts,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>dim,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*p,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*c,</highlight></codeline>
<codeline lineno="393"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*r1,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*r2)</highlight></codeline>
<codeline lineno="394"><highlight class="normal">{</highlight></codeline>
<codeline lineno="395"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>i;</highlight></codeline>
<codeline lineno="396"><highlight class="normal"></highlight></codeline>
<codeline lineno="397"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>memcpy(pts,<sp/>p,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">)<sp/>*<sp/>dim);<sp/>pts<sp/>+=<sp/>dim;</highlight></codeline>
<codeline lineno="398"><highlight class="normal"></highlight></codeline>
<codeline lineno="399"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>dim;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="400"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>p[i]<sp/>=<sp/>c[i]<sp/>-<sp/>r1[i];</highlight></codeline>
<codeline lineno="401"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>memcpy(pts,<sp/>p,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">)<sp/>*<sp/>dim);<sp/>pts<sp/>+=<sp/>dim;</highlight></codeline>
<codeline lineno="402"><highlight class="normal"></highlight></codeline>
<codeline lineno="403"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>p[i]<sp/>=<sp/>c[i]<sp/>+<sp/>r1[i];</highlight></codeline>
<codeline lineno="404"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>memcpy(pts,<sp/>p,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">)<sp/>*<sp/>dim);<sp/>pts<sp/>+=<sp/>dim;</highlight></codeline>
<codeline lineno="405"><highlight class="normal"></highlight></codeline>
<codeline lineno="406"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>p[i]<sp/>=<sp/>c[i]<sp/>-<sp/>r2[i];</highlight></codeline>
<codeline lineno="407"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>memcpy(pts,<sp/>p,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">)<sp/>*<sp/>dim);<sp/>pts<sp/>+=<sp/>dim;</highlight></codeline>
<codeline lineno="408"><highlight class="normal"></highlight></codeline>
<codeline lineno="409"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>p[i]<sp/>=<sp/>c[i]<sp/>+<sp/>r2[i];</highlight></codeline>
<codeline lineno="410"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>memcpy(pts,<sp/>p,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">)<sp/>*<sp/>dim);<sp/>pts<sp/>+=<sp/>dim;</highlight></codeline>
<codeline lineno="411"><highlight class="normal"></highlight></codeline>
<codeline lineno="412"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>p[i]<sp/>=<sp/>c[i];</highlight></codeline>
<codeline lineno="413"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="414"><highlight class="normal">}</highlight></codeline>
<codeline lineno="415"><highlight class="normal"></highlight></codeline>
<codeline lineno="416"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>num0_0(dim)<sp/>(1U)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="417"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>numR0_0fs(dim)<sp/>(2<sp/>*<sp/>(dim))</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="418"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>numRR0_0fs(dim)<sp/>(2<sp/>*<sp/>(dim)<sp/>*<sp/>(dim-1))</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="419"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>numR_Rfs(dim)<sp/>(1U<sp/>&lt;&lt;<sp/>(dim))</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="420"><highlight class="normal"></highlight></codeline>
<codeline lineno="421"><highlight class="normal"></highlight><highlight class="comment">/***************************************************************************/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="422"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Based<sp/>on<sp/>rule75genzmalik.cpp<sp/>in<sp/>HIntLib-0.0.10:<sp/>An<sp/>embedded</highlight></codeline>
<codeline lineno="423"><highlight class="comment"><sp/><sp/><sp/>cubature<sp/>rule<sp/>of<sp/>degree<sp/>7<sp/>(embedded<sp/>rule<sp/>degree<sp/>5)<sp/>due<sp/>to<sp/>A.<sp/>C.<sp/>Genz</highlight></codeline>
<codeline lineno="424"><highlight class="comment"><sp/><sp/><sp/>and<sp/>A.<sp/>A.<sp/>Malik.<sp/><sp/>See:</highlight></codeline>
<codeline lineno="425"><highlight class="comment"></highlight></codeline>
<codeline lineno="426"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>A.<sp/>C.<sp/>Genz<sp/>and<sp/>A.<sp/>A.<sp/>Malik,<sp/>&quot;An<sp/>imbedded<sp/>[sic]<sp/>family<sp/>of<sp/>fully</highlight></codeline>
<codeline lineno="427"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>symmetric<sp/>numerical<sp/>integration<sp/>rules,&quot;<sp/>SIAM</highlight></codeline>
<codeline lineno="428"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>J.<sp/>Numer.<sp/>Anal.<sp/>20<sp/>(3),<sp/>580-588<sp/>(1983).</highlight></codeline>
<codeline lineno="429"><highlight class="comment">*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="430"><highlight class="normal"></highlight></codeline>
<codeline lineno="431" refid="structrule75genzmalik" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="432"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><ref refid="structrule__s" kindref="compound">rule</ref><sp/>parent;</highlight></codeline>
<codeline lineno="433"><highlight class="normal"></highlight></codeline>
<codeline lineno="434"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>temporary<sp/>arrays<sp/>of<sp/>length<sp/>dim<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="435"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*widthLambda,<sp/>*widthLambda2,<sp/>*p;</highlight></codeline>
<codeline lineno="436"><highlight class="normal"></highlight></codeline>
<codeline lineno="437"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>dimension-dependent<sp/>constants<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="438"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>weight1,<sp/>weight3,<sp/>weight5;</highlight></codeline>
<codeline lineno="439"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>weightE1,<sp/>weightE3;</highlight></codeline>
<codeline lineno="440"><highlight class="normal">}<sp/><ref refid="structrule75genzmalik" kindref="compound">rule75genzmalik</ref>;</highlight></codeline>
<codeline lineno="441"><highlight class="normal"></highlight></codeline>
<codeline lineno="442"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>real(x)<sp/>((double)(x))</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="443"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>to_int(n)<sp/>((int)(n))</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="444"><highlight class="normal"></highlight></codeline>
<codeline lineno="445"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>isqr(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>x)</highlight></codeline>
<codeline lineno="446"><highlight class="normal">{</highlight></codeline>
<codeline lineno="447"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>x<sp/>*<sp/>x;</highlight></codeline>
<codeline lineno="448"><highlight class="normal">}</highlight></codeline>
<codeline lineno="449"><highlight class="normal"></highlight></codeline>
<codeline lineno="450"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>destroy_rule75genzmalik(<ref refid="structrule__s" kindref="compound">rule</ref><sp/>*r_)</highlight></codeline>
<codeline lineno="451"><highlight class="normal">{</highlight></codeline>
<codeline lineno="452"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><ref refid="structrule75genzmalik" kindref="compound">rule75genzmalik</ref><sp/>*r<sp/>=<sp/>(<ref refid="structrule75genzmalik" kindref="compound">rule75genzmalik</ref><sp/>*)<sp/>r_;</highlight></codeline>
<codeline lineno="453"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>free(r-&gt;p);</highlight></codeline>
<codeline lineno="454"><highlight class="normal">}</highlight></codeline>
<codeline lineno="455"><highlight class="normal"></highlight></codeline>
<codeline lineno="456"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>rule75genzmalik_evalError(<ref refid="structrule__s" kindref="compound">rule</ref><sp/>*r_,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>fdim,<sp/>integrand_v<sp/>f,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*fdata,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>nR,<sp/><ref refid="structregion" kindref="compound">region</ref><sp/>*R)</highlight></codeline>
<codeline lineno="457"><highlight class="normal">{</highlight></codeline>
<codeline lineno="458"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>lambda2<sp/>=<sp/>sqrt(9/70),<sp/>lambda4<sp/>=<sp/>sqrt(9/10),<sp/>lambda5<sp/>=<sp/>sqrt(9/19)<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="459"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>lambda2<sp/>=<sp/>0.3585685828003180919906451539079374954541;</highlight></codeline>
<codeline lineno="460"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>lambda4<sp/>=<sp/>0.9486832980505137995996680633298155601160;</highlight></codeline>
<codeline lineno="461"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>lambda5<sp/>=<sp/>0.6882472016116852977216287342936235251269;</highlight></codeline>
<codeline lineno="462"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>weight2<sp/>=<sp/>980.<sp/>/<sp/>6561.;</highlight></codeline>
<codeline lineno="463"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>weight4<sp/>=<sp/>200.<sp/>/<sp/>19683.;</highlight></codeline>
<codeline lineno="464"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>weightE2<sp/>=<sp/>245.<sp/>/<sp/>486.;</highlight></codeline>
<codeline lineno="465"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>weightE4<sp/>=<sp/>25.<sp/>/<sp/>729.;</highlight></codeline>
<codeline lineno="466"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>ratio<sp/>=<sp/>(lambda2<sp/>*<sp/>lambda2)<sp/>/<sp/>(lambda4<sp/>*<sp/>lambda4);</highlight></codeline>
<codeline lineno="467"><highlight class="normal"></highlight></codeline>
<codeline lineno="468"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><ref refid="structrule75genzmalik" kindref="compound">rule75genzmalik</ref><sp/>*r<sp/>=<sp/>(<ref refid="structrule75genzmalik" kindref="compound">rule75genzmalik</ref><sp/>*)<sp/>r_;</highlight></codeline>
<codeline lineno="469"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>i,<sp/>j,<sp/>iR,<sp/>dim<sp/>=<sp/>r_-&gt;dim;</highlight></codeline>
<codeline lineno="470"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>npts<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="471"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*diff,<sp/>*pts,<sp/>*vals;</highlight></codeline>
<codeline lineno="472"><highlight class="normal"></highlight></codeline>
<codeline lineno="473"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(alloc_rule_pts(r_,<sp/>nR))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>FAILURE;</highlight></codeline>
<codeline lineno="474"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>pts<sp/>=<sp/>r_-&gt;pts;<sp/>vals<sp/>=<sp/>r_-&gt;vals;</highlight></codeline>
<codeline lineno="475"><highlight class="normal"></highlight></codeline>
<codeline lineno="476"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(iR<sp/>=<sp/>0;<sp/>iR<sp/>&lt;<sp/>nR;<sp/>++iR)<sp/>{</highlight></codeline>
<codeline lineno="477"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*center<sp/>=<sp/>R[iR].h.data;</highlight></codeline>
<codeline lineno="478"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*halfwidth<sp/>=<sp/>R[iR].h.data<sp/>+<sp/>dim;</highlight></codeline>
<codeline lineno="479"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="480"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>dim;<sp/>++i)</highlight></codeline>
<codeline lineno="481"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>r-&gt;p[i]<sp/>=<sp/>center[i];</highlight></codeline>
<codeline lineno="482"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="483"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>dim;<sp/>++i)</highlight></codeline>
<codeline lineno="484"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>r-&gt;widthLambda2[i]<sp/>=<sp/>halfwidth[i]<sp/>*<sp/>lambda2;</highlight></codeline>
<codeline lineno="485"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>for<sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>dim;<sp/>++i)</highlight></codeline>
<codeline lineno="486"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>r-&gt;widthLambda[i]<sp/>=<sp/>halfwidth[i]<sp/>*<sp/>lambda4;</highlight></codeline>
<codeline lineno="487"><highlight class="normal"></highlight></codeline>
<codeline lineno="488"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Evaluate<sp/>points<sp/>in<sp/>the<sp/>center,<sp/>in<sp/>(lambda2,0,...,0)<sp/>and</highlight></codeline>
<codeline lineno="489"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(lambda3=lambda4,<sp/>0,...,0).<sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="490"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>evalR0_0fs4d(pts<sp/>+<sp/>npts*dim,<sp/>dim,<sp/>r-&gt;p,<sp/>center,<sp/></highlight></codeline>
<codeline lineno="491"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>r-&gt;widthLambda2,<sp/>r-&gt;widthLambda);</highlight></codeline>
<codeline lineno="492"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>npts<sp/>+=<sp/>num0_0(dim)<sp/>+<sp/>2<sp/>*<sp/>numR0_0fs(dim);</highlight></codeline>
<codeline lineno="493"><highlight class="normal"></highlight></codeline>
<codeline lineno="494"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Calculate<sp/>points<sp/>for<sp/>(lambda4,<sp/>lambda4,<sp/>0,<sp/>...,0)<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="495"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>evalRR0_0fs(pts<sp/>+<sp/>npts*dim,<sp/>dim,<sp/>r-&gt;p,<sp/>center,<sp/>r-&gt;widthLambda);</highlight></codeline>
<codeline lineno="496"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>npts<sp/>+=<sp/>numRR0_0fs(dim);</highlight></codeline>
<codeline lineno="497"><highlight class="normal"></highlight></codeline>
<codeline lineno="498"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Calculate<sp/>points<sp/>for<sp/>(lambda5,<sp/>lambda5,<sp/>...,<sp/>lambda5)<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="499"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>dim;<sp/>++i)</highlight></codeline>
<codeline lineno="500"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>r-&gt;widthLambda[i]<sp/>=<sp/>halfwidth[i]<sp/>*<sp/>lambda5;</highlight></codeline>
<codeline lineno="501"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>evalR_Rfs(pts<sp/>+<sp/>npts*dim,<sp/>dim,<sp/>r-&gt;p,<sp/>center,<sp/>r-&gt;widthLambda);</highlight></codeline>
<codeline lineno="502"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>npts<sp/>+=<sp/>numR_Rfs(dim);</highlight></codeline>
<codeline lineno="503"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="504"><highlight class="normal"></highlight></codeline>
<codeline lineno="505"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Evaluate<sp/>the<sp/>integrand<sp/>function(s)<sp/>at<sp/>all<sp/>the<sp/>points<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="506"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(f(dim,<sp/>npts,<sp/>pts,<sp/>fdata,<sp/>fdim,<sp/>vals))</highlight></codeline>
<codeline lineno="507"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>FAILURE;</highlight></codeline>
<codeline lineno="508"><highlight class="normal"></highlight></codeline>
<codeline lineno="509"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>we<sp/>are<sp/>done<sp/>with<sp/>the<sp/>points,<sp/>and<sp/>so<sp/>we<sp/>can<sp/>re-use<sp/>the<sp/>pts</highlight></codeline>
<codeline lineno="510"><highlight class="comment"><sp/><sp/><sp/><sp/>array<sp/>to<sp/>store<sp/>the<sp/>maximum<sp/>difference<sp/>diff[i]<sp/>in<sp/>each<sp/>dimension<sp/></highlight></codeline>
<codeline lineno="511"><highlight class="comment"><sp/><sp/><sp/><sp/>for<sp/>each<sp/>hypercube<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="512"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>diff<sp/>=<sp/>pts;</highlight></codeline>
<codeline lineno="513"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>dim<sp/>*<sp/>nR;<sp/>++i)<sp/>diff[i]<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="514"><highlight class="normal"></highlight></codeline>
<codeline lineno="515"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>fdim;<sp/>++j)<sp/>{</highlight></codeline>
<codeline lineno="516"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*v<sp/>=<sp/>vals<sp/>+<sp/>j;</highlight></codeline>
<codeline lineno="517"><highlight class="normal"></highlight><highlight class="preprocessor">#<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>define<sp/>VALS(i)<sp/>v[fdim*(i)]<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="518"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(iR<sp/>=<sp/>0;<sp/>iR<sp/>&lt;<sp/>nR;<sp/>++iR)<sp/>{</highlight></codeline>
<codeline lineno="519"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>result,<sp/>res5th;</highlight></codeline>
<codeline lineno="520"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>val0,<sp/>sum2=0,<sp/>sum3=0,<sp/>sum4=0,<sp/>sum5=0;</highlight></codeline>
<codeline lineno="521"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>k,<sp/>k0<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="522"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>accumulate<sp/>j-th<sp/>function<sp/>values<sp/>into<sp/>j-th<sp/>integrals</highlight></codeline>
<codeline lineno="523"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>NOTE:<sp/>this<sp/>relies<sp/>on<sp/>the<sp/>ordering<sp/>of<sp/>the<sp/>eval<sp/>functions</highlight></codeline>
<codeline lineno="524"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>above,<sp/>as<sp/>well<sp/>as<sp/>on<sp/>the<sp/>internal<sp/>structure<sp/>of</highlight></codeline>
<codeline lineno="525"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>the<sp/>evalR0_0fs4d<sp/>function<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="526"><highlight class="normal"></highlight></codeline>
<codeline lineno="527"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>val0<sp/>=<sp/>VALS(0);<sp/></highlight><highlight class="comment">/*<sp/>central<sp/>point<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="528"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>k0<sp/>+=<sp/>1;</highlight></codeline>
<codeline lineno="529"><highlight class="normal"></highlight></codeline>
<codeline lineno="530"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(k<sp/>=<sp/>0;<sp/>k<sp/>&lt;<sp/>dim;<sp/>++k)<sp/>{</highlight></codeline>
<codeline lineno="531"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>v0<sp/>=<sp/>VALS(k0<sp/>+<sp/>4*k);</highlight></codeline>
<codeline lineno="532"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>v1<sp/>=<sp/>VALS((k0<sp/>+<sp/>4*k)<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="533"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>v2<sp/>=<sp/>VALS((k0<sp/>+<sp/>4*k)<sp/>+<sp/>2);</highlight></codeline>
<codeline lineno="534"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>v3<sp/>=<sp/>VALS((k0<sp/>+<sp/>4*k)<sp/>+<sp/>3);</highlight></codeline>
<codeline lineno="535"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="536"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sum2<sp/>+=<sp/>v0<sp/>+<sp/>v1;</highlight></codeline>
<codeline lineno="537"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sum3<sp/>+=<sp/>v2<sp/>+<sp/>v3;</highlight></codeline>
<codeline lineno="538"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="539"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>diff[iR<sp/>*<sp/>dim<sp/>+<sp/>k]<sp/>+=<sp/></highlight></codeline>
<codeline lineno="540"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fabs(v0<sp/>+<sp/>v1<sp/>-<sp/>2*val0<sp/>-<sp/>ratio<sp/>*<sp/>(v2<sp/>+<sp/>v3<sp/>-<sp/>2*val0));</highlight></codeline>
<codeline lineno="541"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="542"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>k0<sp/>+=<sp/>4*k;</highlight></codeline>
<codeline lineno="543"><highlight class="normal"></highlight></codeline>
<codeline lineno="544"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(k<sp/>=<sp/>0;<sp/>k<sp/>&lt;<sp/>numRR0_0fs(dim);<sp/>++k)</highlight></codeline>
<codeline lineno="545"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sum4<sp/>+=<sp/>VALS(k0<sp/>+<sp/>k);</highlight></codeline>
<codeline lineno="546"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>k0<sp/>+=<sp/>k;</highlight></codeline>
<codeline lineno="547"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="548"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(k<sp/>=<sp/>0;<sp/>k<sp/>&lt;<sp/>numR_Rfs(dim);<sp/>++k)</highlight></codeline>
<codeline lineno="549"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sum5<sp/>+=<sp/>VALS(k0<sp/>+<sp/>k);</highlight></codeline>
<codeline lineno="550"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="551"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Calculate<sp/>fifth<sp/>and<sp/>seventh<sp/>order<sp/>results<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="552"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result<sp/>=<sp/>R[iR].h.vol<sp/>*<sp/>(r-&gt;weight1<sp/>*<sp/>val0<sp/>+<sp/>weight2<sp/>*<sp/>sum2<sp/>+<sp/>r-&gt;weight3<sp/>*<sp/>sum3<sp/>+<sp/>weight4<sp/>*<sp/>sum4<sp/>+<sp/>r-&gt;weight5<sp/>*<sp/>sum5);</highlight></codeline>
<codeline lineno="553"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>res5th<sp/>=<sp/>R[iR].h.vol<sp/>*<sp/>(r-&gt;weightE1<sp/>*<sp/>val0<sp/>+<sp/>weightE2<sp/>*<sp/>sum2<sp/>+<sp/>r-&gt;weightE3<sp/>*<sp/>sum3<sp/>+<sp/>weightE4<sp/>*<sp/>sum4);</highlight></codeline>
<codeline lineno="554"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="555"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>R[iR].ee[j].val<sp/>=<sp/>result;</highlight></codeline>
<codeline lineno="556"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>R[iR].ee[j].err<sp/>=<sp/>fabs(res5th<sp/>-<sp/>result);</highlight></codeline>
<codeline lineno="557"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="558"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>v<sp/>+=<sp/>r_-&gt;num_points<sp/>*<sp/>fdim;</highlight></codeline>
<codeline lineno="559"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="560"><highlight class="normal"></highlight><highlight class="preprocessor">#<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>undef<sp/>VALS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="561"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="562"><highlight class="normal"></highlight></codeline>
<codeline lineno="563"><highlight class="normal"></highlight></codeline>
<codeline lineno="564"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>figure<sp/>out<sp/>dimension<sp/>to<sp/>split:<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="565"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(iR<sp/>=<sp/>0;<sp/>iR<sp/>&lt;<sp/>nR;<sp/>++iR)<sp/>{</highlight></codeline>
<codeline lineno="566"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>maxdiff<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="567"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>dimDiffMax<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="568"><highlight class="normal"></highlight></codeline>
<codeline lineno="569"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>dim;<sp/>++i)</highlight></codeline>
<codeline lineno="570"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(diff[iR*dim<sp/>+<sp/>i]<sp/>&gt;<sp/>maxdiff)<sp/>{</highlight></codeline>
<codeline lineno="571"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>maxdiff<sp/>=<sp/>diff[iR*dim<sp/>+<sp/>i];</highlight></codeline>
<codeline lineno="572"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dimDiffMax<sp/>=<sp/>i;</highlight></codeline>
<codeline lineno="573"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="574"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>R[iR].splitDim<sp/>=<sp/>dimDiffMax;</highlight></codeline>
<codeline lineno="575"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="576"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>SUCCESS;</highlight></codeline>
<codeline lineno="577"><highlight class="normal">}</highlight></codeline>
<codeline lineno="578"><highlight class="normal"></highlight></codeline>
<codeline lineno="579"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="structrule__s" kindref="compound">rule</ref><sp/>*make_rule75genzmalik(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>dim,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>fdim)</highlight></codeline>
<codeline lineno="580"><highlight class="normal">{</highlight></codeline>
<codeline lineno="581"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><ref refid="structrule75genzmalik" kindref="compound">rule75genzmalik</ref><sp/>*r;</highlight></codeline>
<codeline lineno="582"><highlight class="normal"></highlight></codeline>
<codeline lineno="583"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(dim<sp/>&lt;<sp/>2)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;<sp/></highlight><highlight class="comment">/*<sp/>this<sp/>rule<sp/>does<sp/>not<sp/>support<sp/>1d<sp/>integrals<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="584"><highlight class="normal"></highlight></codeline>
<codeline lineno="585"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Because<sp/>of<sp/>the<sp/>use<sp/>of<sp/>a<sp/>bit-field<sp/>in<sp/>evalR_Rfs,<sp/>we<sp/>are<sp/>limited</highlight></codeline>
<codeline lineno="586"><highlight class="comment"><sp/><sp/><sp/><sp/>to<sp/>be<sp/>&lt;<sp/>32<sp/>dimensions<sp/>(or<sp/>however<sp/>many<sp/>bits<sp/>are<sp/>in<sp/>unsigned).</highlight></codeline>
<codeline lineno="587"><highlight class="comment"><sp/><sp/><sp/><sp/>This<sp/>is<sp/>not<sp/>a<sp/>practical<sp/>limitation...long<sp/>before<sp/>you<sp/>reach</highlight></codeline>
<codeline lineno="588"><highlight class="comment"><sp/><sp/><sp/><sp/>32<sp/>dimensions,<sp/>the<sp/>Genz-Malik<sp/>cubature<sp/>becomes<sp/>excruciatingly</highlight></codeline>
<codeline lineno="589"><highlight class="comment"><sp/><sp/><sp/><sp/>slow<sp/>and<sp/>is<sp/>superseded<sp/>by<sp/>other<sp/>methods<sp/>(e.g.<sp/>Monte-Carlo).<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="590"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(dim<sp/>&gt;=<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal">)<sp/>*<sp/>8)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="591"><highlight class="normal"></highlight></codeline>
<codeline lineno="592"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>r<sp/>=<sp/>(<ref refid="structrule75genzmalik" kindref="compound">rule75genzmalik</ref><sp/>*)<sp/>make_rule(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="structrule75genzmalik" kindref="compound">rule75genzmalik</ref>),</highlight></codeline>
<codeline lineno="593"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dim,<sp/>fdim,</highlight></codeline>
<codeline lineno="594"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>num0_0(dim)<sp/>+<sp/>2<sp/>*<sp/>numR0_0fs(dim)</highlight></codeline>
<codeline lineno="595"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+<sp/>numRR0_0fs(dim)<sp/>+<sp/>numR_Rfs(dim),</highlight></codeline>
<codeline lineno="596"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>rule75genzmalik_evalError,</highlight></codeline>
<codeline lineno="597"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>destroy_rule75genzmalik);</highlight></codeline>
<codeline lineno="598"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!r)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="599"><highlight class="normal"></highlight></codeline>
<codeline lineno="600"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>r-&gt;weight1<sp/>=<sp/>(real(12824<sp/>-<sp/>9120<sp/>*<sp/>to_int(dim)<sp/>+<sp/>400<sp/>*<sp/>isqr(to_int(dim)))</highlight></codeline>
<codeline lineno="601"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/<sp/>real(19683));</highlight></codeline>
<codeline lineno="602"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>r-&gt;weight3<sp/>=<sp/>real(1820<sp/>-<sp/>400<sp/>*<sp/>to_int(dim))<sp/>/<sp/>real(19683);</highlight></codeline>
<codeline lineno="603"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>r-&gt;weight5<sp/>=<sp/>real(6859)<sp/>/<sp/>real(19683)<sp/>/<sp/>real(1U<sp/>&lt;&lt;<sp/>dim);</highlight></codeline>
<codeline lineno="604"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>r-&gt;weightE1<sp/>=<sp/>(real(729<sp/>-<sp/>950<sp/>*<sp/>to_int(dim)<sp/>+<sp/>50<sp/>*<sp/>isqr(to_int(dim)))</highlight></codeline>
<codeline lineno="605"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>/<sp/>real(729));</highlight></codeline>
<codeline lineno="606"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>r-&gt;weightE3<sp/>=<sp/>real(265<sp/>-<sp/>100<sp/>*<sp/>to_int(dim))<sp/>/<sp/>real(1458);</highlight></codeline>
<codeline lineno="607"><highlight class="normal"></highlight></codeline>
<codeline lineno="608"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>r-&gt;p<sp/>=<sp/>(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*)<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">)<sp/>*<sp/>dim<sp/>*<sp/>3);</highlight></codeline>
<codeline lineno="609"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!r-&gt;p)<sp/>{<sp/>destroy_rule((<ref refid="structrule__s" kindref="compound">rule</ref><sp/>*)<sp/>r);<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;<sp/>}</highlight></codeline>
<codeline lineno="610"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>r-&gt;widthLambda<sp/>=<sp/>r-&gt;p<sp/>+<sp/>dim;</highlight></codeline>
<codeline lineno="611"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>r-&gt;widthLambda2<sp/>=<sp/>r-&gt;p<sp/>+<sp/>2<sp/>*<sp/>dim;</highlight></codeline>
<codeline lineno="612"><highlight class="normal"></highlight></codeline>
<codeline lineno="613"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(<ref refid="structrule__s" kindref="compound">rule</ref><sp/>*)<sp/>r;</highlight></codeline>
<codeline lineno="614"><highlight class="normal">}</highlight></codeline>
<codeline lineno="615"><highlight class="normal"></highlight></codeline>
<codeline lineno="616"><highlight class="normal"></highlight><highlight class="comment">/***************************************************************************/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="617"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>1d<sp/>15-point<sp/>Gaussian<sp/>quadrature<sp/>rule,<sp/>based<sp/>on<sp/>qk15.c<sp/>and<sp/>qk.c<sp/>in</highlight></codeline>
<codeline lineno="618"><highlight class="comment"><sp/><sp/><sp/>GNU<sp/>GSL<sp/>(which<sp/>in<sp/>turn<sp/>is<sp/>based<sp/>on<sp/>QUADPACK).<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="619"><highlight class="normal"></highlight></codeline>
<codeline lineno="620"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>rule15gauss_evalError(<ref refid="structrule__s" kindref="compound">rule</ref><sp/>*r,</highlight></codeline>
<codeline lineno="621"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>fdim,<sp/>integrand_v<sp/>f,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*fdata,</highlight></codeline>
<codeline lineno="622"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>nR,<sp/><ref refid="structregion" kindref="compound">region</ref><sp/>*R)</highlight></codeline>
<codeline lineno="623"><highlight class="normal">{</highlight></codeline>
<codeline lineno="624"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Gauss<sp/>quadrature<sp/>weights<sp/>and<sp/>kronrod<sp/>quadrature<sp/>abscissae<sp/>and</highlight></codeline>
<codeline lineno="625"><highlight class="comment"><sp/><sp/><sp/><sp/>weights<sp/>as<sp/>evaluated<sp/>with<sp/>80<sp/>decimal<sp/>digit<sp/>arithmetic<sp/>by</highlight></codeline>
<codeline lineno="626"><highlight class="comment"><sp/><sp/><sp/><sp/>L.<sp/>W.<sp/>Fullerton,<sp/>Bell<sp/>Labs,<sp/>Nov.<sp/>1981.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="627"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>n<sp/>=<sp/>8;</highlight></codeline>
<codeline lineno="628"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>xgk[8]<sp/>=<sp/>{<sp/><sp/></highlight><highlight class="comment">/*<sp/>abscissae<sp/>of<sp/>the<sp/>15-point<sp/>kronrod<sp/>rule<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="629"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0.991455371120812639206854697526329,</highlight></codeline>
<codeline lineno="630"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0.949107912342758524526189684047851,</highlight></codeline>
<codeline lineno="631"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0.864864423359769072789712788640926,</highlight></codeline>
<codeline lineno="632"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0.741531185599394439863864773280788,</highlight></codeline>
<codeline lineno="633"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0.586087235467691130294144838258730,</highlight></codeline>
<codeline lineno="634"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0.405845151377397166906606412076961,</highlight></codeline>
<codeline lineno="635"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0.207784955007898467600689403773245,</highlight></codeline>
<codeline lineno="636"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0.000000000000000000000000000000000</highlight></codeline>
<codeline lineno="637"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>xgk[1],<sp/>xgk[3],<sp/>...<sp/>abscissae<sp/>of<sp/>the<sp/>7-point<sp/>gauss<sp/>rule.<sp/></highlight></codeline>
<codeline lineno="638"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>xgk[0],<sp/>xgk[2],<sp/>...<sp/>to<sp/>optimally<sp/>extend<sp/>the<sp/>7-point<sp/>gauss<sp/>rule<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="639"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="640"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>wg[4]<sp/>=<sp/>{<sp/><sp/></highlight><highlight class="comment">/*<sp/>weights<sp/>of<sp/>the<sp/>7-point<sp/>gauss<sp/>rule<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="641"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0.129484966168869693270611432679082,</highlight></codeline>
<codeline lineno="642"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0.279705391489276667901467771423780,</highlight></codeline>
<codeline lineno="643"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0.381830050505118944950369775488975,</highlight></codeline>
<codeline lineno="644"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0.417959183673469387755102040816327</highlight></codeline>
<codeline lineno="645"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="646"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>wgk[8]<sp/>=<sp/>{<sp/></highlight><highlight class="comment">/*<sp/>weights<sp/>of<sp/>the<sp/>15-point<sp/>kronrod<sp/>rule<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="647"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0.022935322010529224963732008058970,</highlight></codeline>
<codeline lineno="648"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0.063092092629978553290700663189204,</highlight></codeline>
<codeline lineno="649"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0.104790010322250183839876322541518,</highlight></codeline>
<codeline lineno="650"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0.140653259715525918745189590510238,</highlight></codeline>
<codeline lineno="651"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0.169004726639267902826583426598550,</highlight></codeline>
<codeline lineno="652"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0.190350578064785409913256402421014,</highlight></codeline>
<codeline lineno="653"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0.204432940075298892414161999234649,</highlight></codeline>
<codeline lineno="654"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>0.209482141084727828012999174891714</highlight></codeline>
<codeline lineno="655"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline lineno="656"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>j,<sp/>k,<sp/>iR;</highlight></codeline>
<codeline lineno="657"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>npts<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="658"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*pts,<sp/>*vals;</highlight></codeline>
<codeline lineno="659"><highlight class="normal"></highlight></codeline>
<codeline lineno="660"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(alloc_rule_pts(r,<sp/>nR))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>FAILURE;</highlight></codeline>
<codeline lineno="661"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>pts<sp/>=<sp/>r-&gt;pts;<sp/>vals<sp/>=<sp/>r-&gt;vals;</highlight></codeline>
<codeline lineno="662"><highlight class="normal"></highlight></codeline>
<codeline lineno="663"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(iR<sp/>=<sp/>0;<sp/>iR<sp/>&lt;<sp/>nR;<sp/>++iR)<sp/>{</highlight></codeline>
<codeline lineno="664"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>center<sp/>=<sp/>R[iR].h.data[0];</highlight></codeline>
<codeline lineno="665"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>halfwidth<sp/>=<sp/>R[iR].h.data[1];</highlight></codeline>
<codeline lineno="666"><highlight class="normal"></highlight></codeline>
<codeline lineno="667"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>pts[npts++]<sp/>=<sp/>center;</highlight></codeline>
<codeline lineno="668"><highlight class="normal"></highlight></codeline>
<codeline lineno="669"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>(n<sp/>-<sp/>1)<sp/>/<sp/>2;<sp/>++j)<sp/>{</highlight></codeline>
<codeline lineno="670"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j2<sp/>=<sp/>2*j<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="671"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>w<sp/>=<sp/>halfwidth<sp/>*<sp/>xgk[j2];</highlight></codeline>
<codeline lineno="672"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pts[npts++]<sp/>=<sp/>center<sp/>-<sp/>w;</highlight></codeline>
<codeline lineno="673"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pts[npts++]<sp/>=<sp/>center<sp/>+<sp/>w;</highlight></codeline>
<codeline lineno="674"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="675"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>n/2;<sp/>++j)<sp/>{</highlight></codeline>
<codeline lineno="676"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j2<sp/>=<sp/>2*j;</highlight></codeline>
<codeline lineno="677"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>w<sp/>=<sp/>halfwidth<sp/>*<sp/>xgk[j2];</highlight></codeline>
<codeline lineno="678"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pts[npts++]<sp/>=<sp/>center<sp/>-<sp/>w;</highlight></codeline>
<codeline lineno="679"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pts[npts++]<sp/>=<sp/>center<sp/>+<sp/>w;</highlight></codeline>
<codeline lineno="680"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="681"><highlight class="normal"></highlight></codeline>
<codeline lineno="682"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>R[iR].splitDim<sp/>=<sp/>0;<sp/></highlight><highlight class="comment">/*<sp/>no<sp/>choice<sp/>but<sp/>to<sp/>divide<sp/>0th<sp/>dimension<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="683"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="684"><highlight class="normal"></highlight></codeline>
<codeline lineno="685"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(f(1,<sp/>npts,<sp/>pts,<sp/>fdata,<sp/>fdim,<sp/>vals))</highlight></codeline>
<codeline lineno="686"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>FAILURE;</highlight></codeline>
<codeline lineno="687"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="688"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(k<sp/>=<sp/>0;<sp/>k<sp/>&lt;<sp/>fdim;<sp/>++k)<sp/>{</highlight></codeline>
<codeline lineno="689"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*vk<sp/>=<sp/>vals<sp/>+<sp/>k;</highlight></codeline>
<codeline lineno="690"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(iR<sp/>=<sp/>0;<sp/>iR<sp/>&lt;<sp/>nR;<sp/>++iR)<sp/>{</highlight></codeline>
<codeline lineno="691"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>halfwidth<sp/>=<sp/>R[iR].h.data[1];</highlight></codeline>
<codeline lineno="692"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>result_gauss<sp/>=<sp/>vk[0]<sp/>*<sp/>wg[n/2<sp/>-<sp/>1];</highlight></codeline>
<codeline lineno="693"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>result_kronrod<sp/>=<sp/>vk[0]<sp/>*<sp/>wgk[n<sp/>-<sp/>1];</highlight></codeline>
<codeline lineno="694"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>result_abs<sp/>=<sp/>fabs(result_kronrod);</highlight></codeline>
<codeline lineno="695"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>result_asc,<sp/>mean,<sp/>err;</highlight></codeline>
<codeline lineno="696"><highlight class="normal"></highlight></codeline>
<codeline lineno="697"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>accumulate<sp/>integrals<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="698"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>npts<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="699"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>(n<sp/>-<sp/>1)<sp/>/<sp/>2;<sp/>++j)<sp/>{</highlight></codeline>
<codeline lineno="700"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j2<sp/>=<sp/>2*j<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="701"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>v<sp/>=<sp/>vk[fdim*npts]<sp/>+<sp/>vk[fdim*npts+fdim];</highlight></codeline>
<codeline lineno="702"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result_gauss<sp/>+=<sp/>wg[j]<sp/>*<sp/>v;</highlight></codeline>
<codeline lineno="703"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result_kronrod<sp/>+=<sp/>wgk[j2]<sp/>*<sp/>v;</highlight></codeline>
<codeline lineno="704"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result_abs<sp/>+=<sp/>wgk[j2]<sp/>*<sp/>(fabs(vk[fdim*npts])<sp/></highlight></codeline>
<codeline lineno="705"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+<sp/>fabs(vk[fdim*npts+fdim]));</highlight></codeline>
<codeline lineno="706"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>npts<sp/>+=<sp/>2;</highlight></codeline>
<codeline lineno="707"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="708"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>n/2;<sp/>++j)<sp/>{</highlight></codeline>
<codeline lineno="709"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j2<sp/>=<sp/>2*j;</highlight></codeline>
<codeline lineno="710"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result_kronrod<sp/>+=<sp/>wgk[j2]<sp/>*<sp/>(vk[fdim*npts]<sp/></highlight></codeline>
<codeline lineno="711"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+<sp/>vk[fdim*npts+fdim]);</highlight></codeline>
<codeline lineno="712"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result_abs<sp/>+=<sp/>wgk[j2]<sp/>*<sp/>(fabs(vk[fdim*npts])<sp/></highlight></codeline>
<codeline lineno="713"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+<sp/>fabs(vk[fdim*npts+fdim]));</highlight></codeline>
<codeline lineno="714"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>npts<sp/>+=<sp/>2;</highlight></codeline>
<codeline lineno="715"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="716"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="717"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>integration<sp/>result<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="718"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>R[iR].ee[k].val<sp/>=<sp/>result_kronrod<sp/>*<sp/>halfwidth;</highlight></codeline>
<codeline lineno="719"><highlight class="normal"></highlight></codeline>
<codeline lineno="720"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>error<sp/>estimate<sp/></highlight></codeline>
<codeline lineno="721"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(from<sp/>GSL,<sp/>probably<sp/>dates<sp/>back<sp/>to<sp/>QUADPACK</highlight></codeline>
<codeline lineno="722"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...<sp/>not<sp/>completely<sp/>clear<sp/>to<sp/>me<sp/>why<sp/>we<sp/>don&apos;t<sp/>just<sp/>use</highlight></codeline>
<codeline lineno="723"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fabs(result_kronrod<sp/>-<sp/>result_gauss)<sp/>*<sp/>halfwidth<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="724"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mean<sp/>=<sp/>result_kronrod<sp/>*<sp/>0.5;</highlight></codeline>
<codeline lineno="725"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result_asc<sp/>=<sp/>wgk[n<sp/>-<sp/>1]<sp/>*<sp/>fabs(vk[0]<sp/>-<sp/>mean);</highlight></codeline>
<codeline lineno="726"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>npts<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="727"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>(n<sp/>-<sp/>1)<sp/>/<sp/>2;<sp/>++j)<sp/>{</highlight></codeline>
<codeline lineno="728"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j2<sp/>=<sp/>2*j<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="729"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result_asc<sp/>+=<sp/>wgk[j2]<sp/>*<sp/>(fabs(vk[fdim*npts]-mean)</highlight></codeline>
<codeline lineno="730"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+<sp/>fabs(vk[fdim*npts+fdim]-mean));</highlight></codeline>
<codeline lineno="731"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>npts<sp/>+=<sp/>2;</highlight></codeline>
<codeline lineno="732"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="733"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>n/2;<sp/>++j)<sp/>{</highlight></codeline>
<codeline lineno="734"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j2<sp/>=<sp/>2*j;</highlight></codeline>
<codeline lineno="735"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result_asc<sp/>+=<sp/>wgk[j2]<sp/>*<sp/>(fabs(vk[fdim*npts]-mean)</highlight></codeline>
<codeline lineno="736"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>+<sp/>fabs(vk[fdim*npts+fdim]-mean));</highlight></codeline>
<codeline lineno="737"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>npts<sp/>+=<sp/>2;</highlight></codeline>
<codeline lineno="738"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="739"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>err<sp/>=<sp/>fabs(result_kronrod<sp/>-<sp/>result_gauss)<sp/>*<sp/>halfwidth;</highlight></codeline>
<codeline lineno="740"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result_abs<sp/>*=<sp/>halfwidth;</highlight></codeline>
<codeline lineno="741"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>result_asc<sp/>*=<sp/>halfwidth;</highlight></codeline>
<codeline lineno="742"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(result_asc<sp/>!=<sp/>0<sp/>&amp;&amp;<sp/>err<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="743"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>scale<sp/>=<sp/>pow((200<sp/>*<sp/>err<sp/>/<sp/>result_asc),<sp/>1.5);</highlight></codeline>
<codeline lineno="744"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>err<sp/>=<sp/>(scale<sp/>&lt;<sp/>1)<sp/>?<sp/>result_asc<sp/>*<sp/>scale<sp/>:<sp/>result_asc;</highlight></codeline>
<codeline lineno="745"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="746"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(result_abs<sp/>&gt;<sp/>DBL_MIN<sp/>/<sp/>(50<sp/>*<sp/>DBL_EPSILON))<sp/>{</highlight></codeline>
<codeline lineno="747"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>min_err<sp/>=<sp/>50<sp/>*<sp/>DBL_EPSILON<sp/>*<sp/>result_abs;</highlight></codeline>
<codeline lineno="748"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(min_err<sp/>&gt;<sp/>err)<sp/>err<sp/>=<sp/>min_err;</highlight></codeline>
<codeline lineno="749"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="750"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>R[iR].ee[k].err<sp/>=<sp/>err;</highlight></codeline>
<codeline lineno="751"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="752"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>increment<sp/>vk<sp/>to<sp/>point<sp/>to<sp/>next<sp/>batch<sp/>of<sp/>results<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="753"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>vk<sp/>+=<sp/>15*fdim;</highlight></codeline>
<codeline lineno="754"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="755"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="756"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>SUCCESS;</highlight></codeline>
<codeline lineno="757"><highlight class="normal">}</highlight></codeline>
<codeline lineno="758"><highlight class="normal"></highlight></codeline>
<codeline lineno="759"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="structrule__s" kindref="compound">rule</ref><sp/>*make_rule15gauss(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>dim,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>fdim)</highlight></codeline>
<codeline lineno="760"><highlight class="normal">{</highlight></codeline>
<codeline lineno="761"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(dim<sp/>!=<sp/>1)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;<sp/></highlight><highlight class="comment">/*<sp/>this<sp/>rule<sp/>is<sp/>only<sp/>for<sp/>1d<sp/>integrals<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="762"><highlight class="normal"></highlight></codeline>
<codeline lineno="763"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>make_rule(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="structrule__s" kindref="compound">rule</ref>),<sp/>dim,<sp/>fdim,<sp/>15,</highlight></codeline>
<codeline lineno="764"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>rule15gauss_evalError,<sp/>0);</highlight></codeline>
<codeline lineno="765"><highlight class="normal">}</highlight></codeline>
<codeline lineno="766"><highlight class="normal"></highlight></codeline>
<codeline lineno="767"><highlight class="normal"></highlight><highlight class="comment">/***************************************************************************/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="768"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>binary<sp/>heap<sp/>implementation<sp/>(ala<sp/>_Introduction<sp/>to<sp/>Algorithms_<sp/>by</highlight></codeline>
<codeline lineno="769"><highlight class="comment"><sp/><sp/><sp/>Cormen,<sp/>Leiserson,<sp/>and<sp/>Rivest),<sp/>for<sp/>use<sp/>as<sp/>a<sp/>priority<sp/>queue<sp/>of</highlight></codeline>
<codeline lineno="770"><highlight class="comment"><sp/><sp/><sp/>regions<sp/>to<sp/>integrate.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="771"><highlight class="normal"></highlight></codeline>
<codeline lineno="772"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/><ref refid="structregion" kindref="compound">region</ref><sp/><ref refid="structregion" kindref="compound">heap_item</ref>;</highlight></codeline>
<codeline lineno="773"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>KEY(hi)<sp/>((hi).errmax)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="774"><highlight class="normal"></highlight></codeline>
<codeline lineno="775" refid="structheap" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="776"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>n,<sp/>nalloc;</highlight></codeline>
<codeline lineno="777"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><ref refid="structregion" kindref="compound">heap_item</ref><sp/>*items;</highlight></codeline>
<codeline lineno="778"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>fdim;</highlight></codeline>
<codeline lineno="779"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><ref refid="structesterr" kindref="compound">esterr</ref><sp/>*ee;<sp/></highlight><highlight class="comment">/*<sp/>array<sp/>of<sp/>length<sp/>fdim<sp/>of<sp/>the<sp/>total<sp/>integrand<sp/>&amp;<sp/>error<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="780"><highlight class="normal">}<sp/><ref refid="structheap" kindref="compound">heap</ref>;</highlight></codeline>
<codeline lineno="781"><highlight class="normal"></highlight></codeline>
<codeline lineno="782"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>heap_resize(<ref refid="structheap" kindref="compound">heap</ref><sp/>*h,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>nalloc)</highlight></codeline>
<codeline lineno="783"><highlight class="normal">{</highlight></codeline>
<codeline lineno="784"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>h-&gt;nalloc<sp/>=<sp/>nalloc;</highlight></codeline>
<codeline lineno="785"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nalloc)</highlight></codeline>
<codeline lineno="786"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>h-&gt;items<sp/>=<sp/>(<ref refid="structregion" kindref="compound">heap_item</ref><sp/>*)<sp/>realloc(h-&gt;items,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="structregion" kindref="compound">heap_item</ref>)*nalloc);</highlight></codeline>
<codeline lineno="787"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="788"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>BSD<sp/>realloc<sp/>does<sp/>not<sp/>free<sp/>for<sp/>a<sp/>zero-sized<sp/>reallocation<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="789"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(h-&gt;items);</highlight></codeline>
<codeline lineno="790"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>h-&gt;items<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="791"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="792"><highlight class="normal">}</highlight></codeline>
<codeline lineno="793"><highlight class="normal"></highlight></codeline>
<codeline lineno="794"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="structheap" kindref="compound">heap</ref><sp/>heap_alloc(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>nalloc,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>fdim)</highlight></codeline>
<codeline lineno="795"><highlight class="normal">{</highlight></codeline>
<codeline lineno="796"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><ref refid="structheap" kindref="compound">heap</ref><sp/>h;</highlight></codeline>
<codeline lineno="797"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>i;</highlight></codeline>
<codeline lineno="798"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>h.n<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="799"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>h.nalloc<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="800"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>h.items<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="801"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>h.fdim<sp/>=<sp/>fdim;</highlight></codeline>
<codeline lineno="802"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>h.ee<sp/>=<sp/>(<ref refid="structesterr" kindref="compound">esterr</ref><sp/>*)<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="structesterr" kindref="compound">esterr</ref>)<sp/>*<sp/>fdim);</highlight></codeline>
<codeline lineno="803"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(h.ee)<sp/>{</highlight></codeline>
<codeline lineno="804"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>fdim;<sp/>++i)<sp/>h.ee[i].val<sp/>=<sp/>h.ee[i].err<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="805"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>heap_resize(&amp;h,<sp/>nalloc);</highlight></codeline>
<codeline lineno="806"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="807"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>h;</highlight></codeline>
<codeline lineno="808"><highlight class="normal">}</highlight></codeline>
<codeline lineno="809"><highlight class="normal"></highlight></codeline>
<codeline lineno="810"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>note<sp/>that<sp/>heap_free<sp/>does<sp/>not<sp/>deallocate<sp/>anything<sp/>referenced<sp/>by<sp/>the<sp/>items<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="811"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>heap_free(<ref refid="structheap" kindref="compound">heap</ref><sp/>*h)</highlight></codeline>
<codeline lineno="812"><highlight class="normal">{</highlight></codeline>
<codeline lineno="813"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>h-&gt;n<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="814"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>heap_resize(h,<sp/>0);</highlight></codeline>
<codeline lineno="815"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>h-&gt;fdim<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="816"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>free(h-&gt;ee);</highlight></codeline>
<codeline lineno="817"><highlight class="normal">}</highlight></codeline>
<codeline lineno="818"><highlight class="normal"></highlight></codeline>
<codeline lineno="819"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>heap_push(<ref refid="structheap" kindref="compound">heap</ref><sp/>*h,<sp/><ref refid="structregion" kindref="compound">heap_item</ref><sp/>hi)</highlight></codeline>
<codeline lineno="820"><highlight class="normal">{</highlight></codeline>
<codeline lineno="821"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>insert;</highlight></codeline>
<codeline lineno="822"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>i,<sp/>fdim<sp/>=<sp/>h-&gt;fdim;</highlight></codeline>
<codeline lineno="823"><highlight class="normal"></highlight></codeline>
<codeline lineno="824"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>fdim;<sp/>++i)<sp/>{</highlight></codeline>
<codeline lineno="825"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>h-&gt;ee[i].val<sp/>+=<sp/>hi.ee[i].val;</highlight></codeline>
<codeline lineno="826"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>h-&gt;ee[i].err<sp/>+=<sp/>hi.ee[i].err;</highlight></codeline>
<codeline lineno="827"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="828"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>insert<sp/>=<sp/>h-&gt;n;</highlight></codeline>
<codeline lineno="829"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(++(h-&gt;n)<sp/>&gt;<sp/>h-&gt;nalloc)<sp/>{</highlight></codeline>
<codeline lineno="830"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>heap_resize(h,<sp/>h-&gt;n<sp/>*<sp/>2);</highlight></codeline>
<codeline lineno="831"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!h-&gt;items)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>FAILURE;</highlight></codeline>
<codeline lineno="832"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="833"><highlight class="normal"></highlight></codeline>
<codeline lineno="834"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(insert)<sp/>{</highlight></codeline>
<codeline lineno="835"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>parent<sp/>=<sp/>(insert<sp/>-<sp/>1)<sp/>/<sp/>2;</highlight></codeline>
<codeline lineno="836"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(KEY(hi)<sp/>&lt;=<sp/>KEY(h-&gt;items[parent]))</highlight></codeline>
<codeline lineno="837"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="838"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>h-&gt;items[insert]<sp/>=<sp/>h-&gt;items[parent];</highlight></codeline>
<codeline lineno="839"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>insert<sp/>=<sp/>parent;</highlight></codeline>
<codeline lineno="840"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="841"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>h-&gt;items[insert]<sp/>=<sp/>hi;</highlight></codeline>
<codeline lineno="842"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>SUCCESS;</highlight></codeline>
<codeline lineno="843"><highlight class="normal">}</highlight></codeline>
<codeline lineno="844"><highlight class="normal"></highlight></codeline>
<codeline lineno="845"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>heap_push_many(<ref refid="structheap" kindref="compound">heap</ref><sp/>*h,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>ni,<sp/><ref refid="structregion" kindref="compound">heap_item</ref><sp/>*hi)</highlight></codeline>
<codeline lineno="846"><highlight class="normal">{</highlight></codeline>
<codeline lineno="847"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i;</highlight></codeline>
<codeline lineno="848"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>ni;<sp/>++i)</highlight></codeline>
<codeline lineno="849"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(heap_push(h,<sp/>hi[i]))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>FAILURE;</highlight></codeline>
<codeline lineno="850"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>SUCCESS;</highlight></codeline>
<codeline lineno="851"><highlight class="normal">}</highlight></codeline>
<codeline lineno="852"><highlight class="normal"></highlight></codeline>
<codeline lineno="853"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="structregion" kindref="compound">heap_item</ref><sp/>heap_pop(<ref refid="structheap" kindref="compound">heap</ref><sp/>*h)</highlight></codeline>
<codeline lineno="854"><highlight class="normal">{</highlight></codeline>
<codeline lineno="855"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><ref refid="structregion" kindref="compound">heap_item</ref><sp/>ret;</highlight></codeline>
<codeline lineno="856"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/>n,<sp/>child;</highlight></codeline>
<codeline lineno="857"><highlight class="normal"></highlight></codeline>
<codeline lineno="858"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!(h-&gt;n))<sp/>{</highlight></codeline>
<codeline lineno="859"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>fprintf(stderr,<sp/></highlight><highlight class="stringliteral">&quot;attempted<sp/>to<sp/>pop<sp/>an<sp/>empty<sp/>heap\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="860"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>exit(EXIT_FAILURE);</highlight></codeline>
<codeline lineno="861"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="862"><highlight class="normal"></highlight></codeline>
<codeline lineno="863"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>h-&gt;items[0];</highlight></codeline>
<codeline lineno="864"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>h-&gt;items[i<sp/>=<sp/>0]<sp/>=<sp/>h-&gt;items[n<sp/>=<sp/>--(h-&gt;n)];</highlight></codeline>
<codeline lineno="865"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>((child<sp/>=<sp/>i<sp/>*<sp/>2<sp/>+<sp/>1)<sp/>&lt;<sp/>n)<sp/>{</highlight></codeline>
<codeline lineno="866"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>largest;</highlight></codeline>
<codeline lineno="867"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structregion" kindref="compound">heap_item</ref><sp/>swap;</highlight></codeline>
<codeline lineno="868"><highlight class="normal"></highlight></codeline>
<codeline lineno="869"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(KEY(h-&gt;items[child])<sp/>&lt;=<sp/>KEY(h-&gt;items[i]))</highlight></codeline>
<codeline lineno="870"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>largest<sp/>=<sp/>i;</highlight></codeline>
<codeline lineno="871"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="872"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>largest<sp/>=<sp/>child;</highlight></codeline>
<codeline lineno="873"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(++child<sp/>&lt;<sp/>n<sp/>&amp;&amp;<sp/>KEY(h-&gt;items[largest])<sp/>&lt;<sp/>KEY(h-&gt;items[child]))</highlight></codeline>
<codeline lineno="874"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>largest<sp/>=<sp/>child;</highlight></codeline>
<codeline lineno="875"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(largest<sp/>==<sp/>i)</highlight></codeline>
<codeline lineno="876"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="877"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>swap<sp/>=<sp/>h-&gt;items[i];</highlight></codeline>
<codeline lineno="878"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>h-&gt;items[i]<sp/>=<sp/>h-&gt;items[largest];</highlight></codeline>
<codeline lineno="879"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>h-&gt;items[i<sp/>=<sp/>largest]<sp/>=<sp/>swap;</highlight></codeline>
<codeline lineno="880"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="881"><highlight class="normal"></highlight></codeline>
<codeline lineno="882"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="883"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>i,<sp/>fdim<sp/>=<sp/>h-&gt;fdim;</highlight></codeline>
<codeline lineno="884"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>fdim;<sp/>++i)<sp/>{</highlight></codeline>
<codeline lineno="885"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>h-&gt;ee[i].val<sp/>-=<sp/>ret.ee[i].val;</highlight></codeline>
<codeline lineno="886"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>h-&gt;ee[i].err<sp/>-=<sp/>ret.ee[i].err;</highlight></codeline>
<codeline lineno="887"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="888"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="889"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ret;</highlight></codeline>
<codeline lineno="890"><highlight class="normal">}</highlight></codeline>
<codeline lineno="891"><highlight class="normal"></highlight></codeline>
<codeline lineno="892"><highlight class="normal"></highlight><highlight class="comment">/***************************************************************************/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="893"><highlight class="normal"></highlight></codeline>
<codeline lineno="894"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>converged(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>fdim,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structesterr" kindref="compound">esterr</ref><sp/>*ee,</highlight></codeline>
<codeline lineno="895"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>reqAbsError,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>reqRelError,<sp/>error_norm<sp/>norm)</highlight></codeline>
<codeline lineno="896"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>ERR(j)<sp/>ee[j].err</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="897"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>VAL(j)<sp/>ee[j].val</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="898"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;converged.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="899"><highlight class="normal"></highlight></codeline>
<codeline lineno="900"><highlight class="normal"></highlight><highlight class="comment">/***************************************************************************/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="901"><highlight class="normal"></highlight></codeline>
<codeline lineno="902"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>adaptive<sp/>integration,<sp/>analogous<sp/>to<sp/>adaptintegrator.cpp<sp/>in<sp/>HIntLib<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="903"><highlight class="normal"></highlight></codeline>
<codeline lineno="904"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>rulecubature(<ref refid="structrule__s" kindref="compound">rule</ref><sp/>*r,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>fdim,<sp/></highlight></codeline>
<codeline lineno="905"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>integrand_v<sp/>f,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*fdata,<sp/></highlight></codeline>
<codeline lineno="906"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structhypercube" kindref="compound">hypercube</ref><sp/>*h,<sp/></highlight></codeline>
<codeline lineno="907"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>maxEval,</highlight></codeline>
<codeline lineno="908"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>reqAbsError,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>reqRelError,</highlight></codeline>
<codeline lineno="909"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error_norm<sp/>norm,</highlight></codeline>
<codeline lineno="910"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*val,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*err,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>parallel)</highlight></codeline>
<codeline lineno="911"><highlight class="normal">{</highlight></codeline>
<codeline lineno="912"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>numEval<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="913"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><ref refid="structheap" kindref="compound">heap</ref><sp/>regions;</highlight></codeline>
<codeline lineno="914"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>i,<sp/>j;</highlight></codeline>
<codeline lineno="915"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><ref refid="structregion" kindref="compound">region</ref><sp/>*R<sp/>=<sp/>NULL;<sp/></highlight><highlight class="comment">/*<sp/>array<sp/>of<sp/>regions<sp/>to<sp/>evaluate<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="916"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>nR_alloc<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="917"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><ref refid="structesterr" kindref="compound">esterr</ref><sp/>*ee<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="918"><highlight class="normal"></highlight></codeline>
<codeline lineno="919"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(fdim<sp/>&lt;=<sp/>1)<sp/>norm<sp/>=<sp/>ERROR_INDIVIDUAL;<sp/></highlight><highlight class="comment">/*<sp/>norm<sp/>is<sp/>irrelevant<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="920"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(norm<sp/>&lt;<sp/>0<sp/>||<sp/>norm<sp/>&gt;<sp/>ERROR_LINF)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>FAILURE;<sp/></highlight><highlight class="comment">/*<sp/>invalid<sp/>norm<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="921"><highlight class="normal"></highlight></codeline>
<codeline lineno="922"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>regions<sp/>=<sp/>heap_alloc(1,<sp/>fdim);</highlight></codeline>
<codeline lineno="923"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!regions.ee<sp/>||<sp/>!regions.items)<sp/></highlight><highlight class="keywordflow">goto</highlight><highlight class="normal"><sp/>bad;</highlight></codeline>
<codeline lineno="924"><highlight class="normal"></highlight></codeline>
<codeline lineno="925"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>ee<sp/>=<sp/>(<ref refid="structesterr" kindref="compound">esterr</ref><sp/>*)<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="structesterr" kindref="compound">esterr</ref>)<sp/>*<sp/>fdim);</highlight></codeline>
<codeline lineno="926"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ee)<sp/></highlight><highlight class="keywordflow">goto</highlight><highlight class="normal"><sp/>bad;</highlight></codeline>
<codeline lineno="927"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="928"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>nR_alloc<sp/>=<sp/>2;</highlight></codeline>
<codeline lineno="929"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>R<sp/>=<sp/>(<ref refid="structregion" kindref="compound">region</ref><sp/>*)<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="structregion" kindref="compound">region</ref>)<sp/>*<sp/>nR_alloc);</highlight></codeline>
<codeline lineno="930"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!R)<sp/></highlight><highlight class="keywordflow">goto</highlight><highlight class="normal"><sp/>bad;</highlight></codeline>
<codeline lineno="931"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>R[0]<sp/>=<sp/>make_region(h,<sp/>fdim);</highlight></codeline>
<codeline lineno="932"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!R[0].ee</highlight></codeline>
<codeline lineno="933"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>||<sp/>eval_regions(1,<sp/>R,<sp/>f,<sp/>fdata,<sp/>r)</highlight></codeline>
<codeline lineno="934"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>||<sp/>heap_push(&amp;regions,<sp/>R[0]))</highlight></codeline>
<codeline lineno="935"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">goto</highlight><highlight class="normal"><sp/>bad;</highlight></codeline>
<codeline lineno="936"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>numEval<sp/>+=<sp/>r-&gt;num_points;</highlight></codeline>
<codeline lineno="937"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="938"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(numEval<sp/>&lt;<sp/>maxEval<sp/>||<sp/>!maxEval)<sp/>{</highlight></codeline>
<codeline lineno="939"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(converged(fdim,<sp/>regions.ee,<sp/>reqAbsError,<sp/>reqRelError,<sp/>norm))</highlight></codeline>
<codeline lineno="940"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="941"><highlight class="normal"></highlight></codeline>
<codeline lineno="942"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(parallel)<sp/>{<sp/></highlight><highlight class="comment">/*<sp/>maximize<sp/>potential<sp/>parallelism<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="943"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>adapted<sp/>from<sp/>I.<sp/>Gladwell,<sp/>&quot;Vectorization<sp/>of<sp/>one</highlight></codeline>
<codeline lineno="944"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dimensional<sp/>quadrature<sp/>codes,&quot;<sp/>pp.<sp/>230--238<sp/>in</highlight></codeline>
<codeline lineno="945"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_Numerical<sp/>Integration.<sp/>Recent<sp/>Developments,</highlight></codeline>
<codeline lineno="946"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Software<sp/>and<sp/>Applications_,<sp/>G.<sp/>Fairweather<sp/>and</highlight></codeline>
<codeline lineno="947"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>P.<sp/>M.<sp/>Keast,<sp/>eds.,<sp/>NATO<sp/>ASI<sp/>Series<sp/>C203,<sp/>Dordrecht</highlight></codeline>
<codeline lineno="948"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(1987),<sp/>as<sp/>described<sp/>in<sp/>J.<sp/>M.<sp/>Bull<sp/>and</highlight></codeline>
<codeline lineno="949"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T.<sp/>L.<sp/>Freeman,<sp/>&quot;Parallel<sp/>Globally<sp/>Adaptive</highlight></codeline>
<codeline lineno="950"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Algorithms<sp/>for<sp/>Multi-dimensional<sp/>Integration,&quot;</highlight></codeline>
<codeline lineno="951"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.6638</highlight></codeline>
<codeline lineno="952"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(1994).<sp/></highlight></codeline>
<codeline lineno="953"><highlight class="comment"></highlight></codeline>
<codeline lineno="954"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Basically,<sp/>this<sp/>evaluates<sp/>in<sp/>one<sp/>shot<sp/>all<sp/>regions</highlight></codeline>
<codeline lineno="955"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>that<sp/>*must*<sp/>be<sp/>evaluated<sp/>in<sp/>order<sp/>to<sp/>reduce<sp/>the</highlight></codeline>
<codeline lineno="956"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error<sp/>to<sp/>the<sp/>requested<sp/>bound:<sp/>the<sp/>minimum<sp/>set<sp/>of</highlight></codeline>
<codeline lineno="957"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>largest-error<sp/>regions<sp/>whose<sp/>errors<sp/>push<sp/>the<sp/>total</highlight></codeline>
<codeline lineno="958"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error<sp/>over<sp/>the<sp/>bound.</highlight></codeline>
<codeline lineno="959"><highlight class="comment"></highlight></codeline>
<codeline lineno="960"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>[Note:<sp/>Bull<sp/>and<sp/>Freeman<sp/>claim<sp/>that<sp/>the<sp/>Gladwell</highlight></codeline>
<codeline lineno="961"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>approach<sp/>is<sp/>intrinsically<sp/>inefficent<sp/>because<sp/>it</highlight></codeline>
<codeline lineno="962"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;requires<sp/>sorting&quot;,<sp/>and<sp/>propose<sp/>an<sp/>alternative</highlight></codeline>
<codeline lineno="963"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>algorithm<sp/>that<sp/>&quot;only&quot;<sp/>requires<sp/>three<sp/>passes<sp/>over<sp/>the</highlight></codeline>
<codeline lineno="964"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>entire<sp/>set<sp/>of<sp/>regions.<sp/><sp/>Apparently,<sp/>they<sp/>didn&apos;t</highlight></codeline>
<codeline lineno="965"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>realize<sp/>that<sp/>one<sp/>could<sp/>use<sp/>a<sp/>heap<sp/>data<sp/>structure,<sp/>in</highlight></codeline>
<codeline lineno="966"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>which<sp/>case<sp/>the<sp/>time<sp/>to<sp/>pop<sp/>K<sp/>biggest-error<sp/>regions</highlight></codeline>
<codeline lineno="967"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>out<sp/>of<sp/>N<sp/>is<sp/>only<sp/>O(K<sp/>log<sp/>N),<sp/>much<sp/>better<sp/>than<sp/>the</highlight></codeline>
<codeline lineno="968"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>O(N)<sp/>cost<sp/>of<sp/>the<sp/>Bull<sp/>and<sp/>Freeman<sp/>algorithm<sp/>if<sp/>K<sp/>&lt;&lt;</highlight></codeline>
<codeline lineno="969"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>N,<sp/>and<sp/>it<sp/>is<sp/>also<sp/>much<sp/>simpler.]<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="970"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>nR<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="971"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>fdim;<sp/>++j)<sp/>ee[j]<sp/>=<sp/>regions.ee[j];</highlight></codeline>
<codeline lineno="972"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="973"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(nR<sp/>+<sp/>2<sp/>&gt;<sp/>nR_alloc)<sp/>{</highlight></codeline>
<codeline lineno="974"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nR_alloc<sp/>=<sp/>(nR<sp/>+<sp/>2)<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="975"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>R<sp/>=<sp/>(<ref refid="structregion" kindref="compound">region</ref><sp/>*)<sp/>realloc(R,<sp/>nR_alloc<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="structregion" kindref="compound">region</ref>));</highlight></codeline>
<codeline lineno="976"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!R)<sp/></highlight><highlight class="keywordflow">goto</highlight><highlight class="normal"><sp/>bad;</highlight></codeline>
<codeline lineno="977"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="978"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>R[nR]<sp/>=<sp/>heap_pop(&amp;regions);</highlight></codeline>
<codeline lineno="979"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>fdim;<sp/>++j)<sp/>ee[j].err<sp/>-=<sp/>R[nR].ee[j].err;</highlight></codeline>
<codeline lineno="980"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(cut_region(R+nR,<sp/>R+nR+1))<sp/></highlight><highlight class="keywordflow">goto</highlight><highlight class="normal"><sp/>bad;</highlight></codeline>
<codeline lineno="981"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>numEval<sp/>+=<sp/>r-&gt;num_points<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="982"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>nR<sp/>+=<sp/>2;</highlight></codeline>
<codeline lineno="983"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(converged(fdim,<sp/>ee,<sp/>reqAbsError,<sp/>reqRelError,<sp/>norm))</highlight></codeline>
<codeline lineno="984"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;<sp/></highlight><highlight class="comment">/*<sp/>other<sp/>regions<sp/>have<sp/>small<sp/>errs<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="985"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(regions.n<sp/>&gt;<sp/>0<sp/>&amp;&amp;<sp/>(numEval<sp/>&lt;<sp/>maxEval<sp/>||<sp/>!maxEval));</highlight></codeline>
<codeline lineno="986"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(eval_regions(nR,<sp/>R,<sp/>f,<sp/>fdata,<sp/>r)</highlight></codeline>
<codeline lineno="987"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>||<sp/>heap_push_many(&amp;regions,<sp/>nR,<sp/>R))</highlight></codeline>
<codeline lineno="988"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">goto</highlight><highlight class="normal"><sp/>bad;</highlight></codeline>
<codeline lineno="989"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="990"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{<sp/></highlight><highlight class="comment">/*<sp/>minimize<sp/>number<sp/>of<sp/>function<sp/>evaluations<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="991"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>R[0]<sp/>=<sp/>heap_pop(&amp;regions);<sp/></highlight><highlight class="comment">/*<sp/>get<sp/>worst<sp/>region<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="992"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(cut_region(R,<sp/>R+1)</highlight></codeline>
<codeline lineno="993"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>||<sp/>eval_regions(2,<sp/>R,<sp/>f,<sp/>fdata,<sp/>r)</highlight></codeline>
<codeline lineno="994"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>||<sp/>heap_push_many(&amp;regions,<sp/>2,<sp/>R))</highlight></codeline>
<codeline lineno="995"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">goto</highlight><highlight class="normal"><sp/>bad;</highlight></codeline>
<codeline lineno="996"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>numEval<sp/>+=<sp/>r-&gt;num_points<sp/>*<sp/>2;</highlight></codeline>
<codeline lineno="997"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="998"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="999"><highlight class="normal"></highlight></codeline>
<codeline lineno="1000"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>re-sum<sp/>integral<sp/>and<sp/>errors<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1001"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>fdim;<sp/>++j)<sp/>val[j]<sp/>=<sp/>err[j]<sp/>=<sp/>0;<sp/><sp/></highlight></codeline>
<codeline lineno="1002"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>regions.n;<sp/>++i)<sp/>{</highlight></codeline>
<codeline lineno="1003"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>fdim;<sp/>++j)<sp/>{<sp/></highlight></codeline>
<codeline lineno="1004"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>val[j]<sp/>+=<sp/>regions.items[i].ee[j].val;</highlight></codeline>
<codeline lineno="1005"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>err[j]<sp/>+=<sp/>regions.items[i].ee[j].err;</highlight></codeline>
<codeline lineno="1006"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1007"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>destroy_region(&amp;regions.items[i]);</highlight></codeline>
<codeline lineno="1008"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1009"><highlight class="normal"></highlight></codeline>
<codeline lineno="1010"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>printf(&quot;regions.nalloc<sp/>=<sp/>%d\n&quot;,<sp/>regions.nalloc);<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1011"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>free(ee);</highlight></codeline>
<codeline lineno="1012"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>heap_free(&amp;regions);</highlight></codeline>
<codeline lineno="1013"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>free(R);</highlight></codeline>
<codeline lineno="1014"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>SUCCESS;</highlight></codeline>
<codeline lineno="1015"><highlight class="normal"></highlight></codeline>
<codeline lineno="1016"><highlight class="normal">bad:</highlight></codeline>
<codeline lineno="1017"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>free(ee);</highlight></codeline>
<codeline lineno="1018"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>heap_free(&amp;regions);</highlight></codeline>
<codeline lineno="1019"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>free(R);</highlight></codeline>
<codeline lineno="1020"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>FAILURE;</highlight></codeline>
<codeline lineno="1021"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1022"><highlight class="normal"></highlight></codeline>
<codeline lineno="1023"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>cubature(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>fdim,<sp/>integrand_v<sp/>f,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*fdata,<sp/></highlight></codeline>
<codeline lineno="1024"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>dim,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*xmin,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*xmax,<sp/></highlight></codeline>
<codeline lineno="1025"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>maxEval,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>reqAbsError,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>reqRelError,<sp/></highlight></codeline>
<codeline lineno="1026"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error_norm<sp/>norm,</highlight></codeline>
<codeline lineno="1027"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*val,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*err,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>parallel)</highlight></codeline>
<codeline lineno="1028"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1029"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><ref refid="structrule__s" kindref="compound">rule</ref><sp/>*r;</highlight></codeline>
<codeline lineno="1030"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><ref refid="structhypercube" kindref="compound">hypercube</ref><sp/>h;</highlight></codeline>
<codeline lineno="1031"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>status;</highlight></codeline>
<codeline lineno="1032"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>i;</highlight></codeline>
<codeline lineno="1033"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1034"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(fdim<sp/>==<sp/>0)<sp/></highlight><highlight class="comment">/*<sp/>nothing<sp/>to<sp/>do<sp/>*/</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>SUCCESS;</highlight></codeline>
<codeline lineno="1035"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(dim<sp/>==<sp/>0)<sp/>{<sp/></highlight><highlight class="comment">/*<sp/>trivial<sp/>integration<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1036"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(f(0,<sp/>1,<sp/>xmin,<sp/>fdata,<sp/>fdim,<sp/>val))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>FAILURE;</highlight></codeline>
<codeline lineno="1037"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>fdim;<sp/>++i)<sp/>err[i]<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="1038"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>SUCCESS;</highlight></codeline>
<codeline lineno="1039"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1040"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>r<sp/>=<sp/>dim<sp/>==<sp/>1<sp/>?<sp/>make_rule15gauss(dim,<sp/>fdim)</highlight></codeline>
<codeline lineno="1041"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>make_rule75genzmalik(dim,<sp/>fdim);</highlight></codeline>
<codeline lineno="1042"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!r)<sp/>{<sp/></highlight></codeline>
<codeline lineno="1043"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>fdim;<sp/>++i)<sp/>{</highlight></codeline>
<codeline lineno="1044"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>val[i]<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="1045"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>err[i]<sp/>=<sp/>HUGE_VAL;<sp/></highlight></codeline>
<codeline lineno="1046"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1047"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>FAILURE;</highlight></codeline>
<codeline lineno="1048"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1049"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>h<sp/>=<sp/>make_hypercube_range(dim,<sp/>xmin,<sp/>xmax);</highlight></codeline>
<codeline lineno="1050"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>status<sp/>=<sp/>!h.data<sp/>?<sp/>FAILURE</highlight></codeline>
<codeline lineno="1051"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>:<sp/>rulecubature(r,<sp/>fdim,<sp/>f,<sp/>fdata,<sp/>&amp;h,</highlight></codeline>
<codeline lineno="1052"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>maxEval,<sp/>reqAbsError,<sp/>reqRelError,<sp/>norm,</highlight></codeline>
<codeline lineno="1053"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>val,<sp/>err,<sp/>parallel);</highlight></codeline>
<codeline lineno="1054"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>destroy_hypercube(&amp;h);</highlight></codeline>
<codeline lineno="1055"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>destroy_rule(r);</highlight></codeline>
<codeline lineno="1056"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>status;</highlight></codeline>
<codeline lineno="1057"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1058"><highlight class="normal"></highlight></codeline>
<codeline lineno="1059"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>hcubature_v(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>fdim,<sp/>integrand_v<sp/>f,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*fdata,<sp/></highlight></codeline>
<codeline lineno="1060"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>dim,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*xmin,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*xmax,<sp/></highlight></codeline>
<codeline lineno="1061"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>maxEval,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>reqAbsError,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>reqRelError,<sp/></highlight></codeline>
<codeline lineno="1062"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error_norm<sp/>norm,</highlight></codeline>
<codeline lineno="1063"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*val,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*err)</highlight></codeline>
<codeline lineno="1064"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1065"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>cubature(fdim,<sp/>f,<sp/>fdata,<sp/>dim,<sp/>xmin,<sp/>xmax,<sp/></highlight></codeline>
<codeline lineno="1066"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>maxEval,<sp/>reqAbsError,<sp/>reqRelError,<sp/>norm,<sp/>val,<sp/>err,<sp/>1);</highlight></codeline>
<codeline lineno="1067"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1068"><highlight class="normal"></highlight></codeline>
<codeline lineno="1069"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;vwrapper.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1070"><highlight class="normal"></highlight></codeline>
<codeline lineno="1071"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>hcubature(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>fdim,<sp/>integrand<sp/>f,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*fdata,<sp/></highlight></codeline>
<codeline lineno="1072"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>dim,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*xmin,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*xmax,<sp/></highlight></codeline>
<codeline lineno="1073"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>maxEval,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>reqAbsError,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>reqRelError,<sp/></highlight></codeline>
<codeline lineno="1074"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error_norm<sp/>norm,</highlight></codeline>
<codeline lineno="1075"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*val,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*err)</highlight></codeline>
<codeline lineno="1076"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1077"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ret;</highlight></codeline>
<codeline lineno="1078"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><ref refid="structfv__data__s" kindref="compound">fv_data</ref><sp/>d;</highlight></codeline>
<codeline lineno="1079"><highlight class="normal"></highlight></codeline>
<codeline lineno="1080"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(fdim<sp/>==<sp/>0)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>SUCCESS;<sp/></highlight><highlight class="comment">/*<sp/>nothing<sp/>to<sp/>do<sp/>*/</highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1081"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1082"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>d.f<sp/>=<sp/>f;<sp/>d.fdata<sp/>=<sp/>fdata;</highlight></codeline>
<codeline lineno="1083"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>cubature(fdim,<sp/>fv,<sp/>&amp;d,<sp/>dim,<sp/>xmin,<sp/>xmax,<sp/></highlight></codeline>
<codeline lineno="1084"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>maxEval,<sp/>reqAbsError,<sp/>reqRelError,<sp/>norm,<sp/>val,<sp/>err,<sp/>0);</highlight></codeline>
<codeline lineno="1085"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ret;</highlight></codeline>
<codeline lineno="1086"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1087"><highlight class="normal"></highlight></codeline>
<codeline lineno="1088"><highlight class="normal"></highlight><highlight class="comment">/***************************************************************************/</highlight><highlight class="normal"></highlight></codeline>
    </programlisting>
    <location file="src/hcubature.cpp"/>
  </compounddef>
</doxygen>
